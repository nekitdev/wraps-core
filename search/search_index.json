{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>wraps-core</code>","text":"<p>Core functionality of wraps.</p>"},{"location":"#installing","title":"Installing","text":"<p>Python 3.8 or above is required.</p>"},{"location":"#pip","title":"<code>pip</code>","text":"<p>Installing the library with <code>pip</code> is quite simple:</p> <pre><code>$ pip install wraps-core\n</code></pre> <p>Alternatively, the library can be installed from the source:</p> <pre><code>$ pip install git+https://github.com/nekitdev/wraps-core.git\n</code></pre> <p>Or via cloning the repository:</p> <pre><code>$ git clone https://github.com/nekitdev/wraps-core.git\n$ cd wraps-core\n$ pip install .\n</code></pre>"},{"location":"#uv","title":"<code>uv</code>","text":"<p>You can add <code>wraps-core</code> as a dependency with the following command:</p> <pre><code>$ uv add wraps-core\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#option","title":"Option","text":"<p><code>Option[T]</code> type represents an optional value: every option is either <code>Some[T]</code> and contains a value, or <code>Null</code>, and does not.</p> <p>Here is an example of <code>divide</code> function returning <code>Option[float]</code> instead of raising an error when the denominator is zero:</p> <pre><code># option.py\n\nfrom wraps_core import NULL, Option, Some\n\n\ndef divide(numerator: float, denominator: float) -&gt; Option[float]:\n    return Some(numerator / denominator) if denominator else NULL\n</code></pre> <p>There are two ways to process the resulting option: either via pattern matching or predicates.</p> <pre><code># option_matching.py\n\nfrom wraps_core import Null, Some\n\nfrom option import divide\n\nDIVISION_BY_ZERO = \"division by zero\"\n\nmatch divide(1.0, 2.0):\n    case Some(value):\n        print(value)\n\n    case Null():\n        print(DIVISION_BY_ZERO)\n</code></pre> <pre><code># option_predicates.py\n\nfrom option import divide\n\nDIVISION_BY_ZERO = \"division by zero\"\n\noption = divide(1.0, 2.0)\n\nif option.is_some():\n    # here we know that the `option` is `Some[float]`, so it is safe to unwrap it\n    print(option.unwrap())\n\nelse:\n    # and here we know that the `option` is `Null`\n    print(DIVISION_BY_ZERO)\n</code></pre> <p>Note that both examples are fully type safe.</p>"},{"location":"#result","title":"Result","text":"<p><code>Result[T, E]</code> is the type used for returning and propagating errors. It has two variants, <code>Ok[T]</code>, representing success and containing a value, and <code>Error[E]</code>, representing error and containing an error value.</p> <p>Below is the enhanced <code>divide</code> function from above, now using <code>Result[float, DivideError]</code> instead of <code>Option[float]</code>.</p> <pre><code># result.py\n\nfrom enum import Enum\n\nfrom wraps_core import Error, Ok, Result\n\n\nclass DivideError(Enum):\n    DIVISION_BY_ZERO = \"division by zero\"\n\n\ndef divide(numerator: float, denominator: float) -&gt; Result[float, DivideError]:\n    return Ok(numerator / denominator) if denominator else Error(DivideError.DIVISION_BY_ZERO)\n</code></pre> <p>Using new <code>divide</code> is as simple as the old one:</p> <pre><code># result_matching.py\n\nfrom wraps_core import Error, Ok\n\nfrom result import divide\n\nmatch divide(1.0, 2.0):\n    case Ok(value):\n        print(value)\n\n    case Error(error):\n        print(error.value)  # we use `value` here to get error details\n</code></pre> <pre><code># result_predicates.py\n\nfrom result import divide\n\nresult = divide(1.0, 2.0)\n\nif result.is_ok():\n    # here we know the `result` is `Ok[float]`, so we can unwrap it safely\n    print(result.unwrap())\n\nelse:\n    # and here the `result` is `Error[DivideError]`, so we can unwrap the error safely\n    print(result.unwrap_error().value)\n</code></pre>"},{"location":"#decorators","title":"Decorators","text":""},{"location":"#early-return","title":"Early Return","text":"<p>Early return functionality (like the question mark (<code>?</code>) operator in Rust) is implemented via <code>early</code> methods (for both <code>Option[T]</code> and <code>Result[T, E]</code> types) combined with the <code>@early_option</code> and <code>@early_result</code> decorators respectively.</p> <p>Here is an example using <code>wrap_option_on</code> to catch errors:</p> <pre><code>from wraps_core import Option, early_option, wrap_option_on\n\n\n@wrap_option_on(ValueError)\ndef parse(string: str) -&gt; float:\n    return float(string)\n\n\n@wrap_option_on(ZeroDivisionError)\ndef divide(numerator: float, denominator: float) -&gt; float:\n    return numerator / denominator\n\n\n@early_option\ndef divide_string(x: str, y: str) -&gt; Option[float]:\n    return divide(parse(x).early(), parse(y).early())\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>You can find the documentation here.</p>"},{"location":"#support","title":"Support","text":"<p>If you need support with the library, you can send us an email or refer to the official Discord server.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>You can find the changelog here.</p>"},{"location":"#security-policy","title":"Security Policy","text":"<p>You can find the Security Policy of <code>wraps-core</code> here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you are interested in contributing to <code>wraps-core</code>, make sure to take a look at the Contributing Guide, as well as the Code of Conduct.</p>"},{"location":"#license","title":"License","text":"<p><code>wraps-core</code> is licensed under the MIT License terms. See License for details.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#020-2024-08-08","title":"0.2.0 (2024-08-08)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Added decorators to the library. (#2)</li> </ul>"},{"location":"changelog/#011-2024-08-05","title":"0.1.1 (2024-08-05)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Added <code>py.typed</code> marker. (#1)</li> </ul>"},{"location":"changelog/#010-2024-08-03","title":"0.1.0 (2024-08-03)","text":"<p>Initial release.</p>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct.</p> <p>Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq. Translations are available at https://contributor-covenant.org/translations.</p>"},{"location":"internals/","title":"Internals","text":""},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#reporting","title":"Reporting","text":"<p>Thank you for taking the time to responsibly disclose any problems you find.</p> <p>Do not file public issues as they are open for everyone to see!</p> <p>All security vulnerabilities in <code>wraps-core</code> should be reported by email to security@nekit.dev. Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report.</p> <p>You can encrypt your report using our public key: <code>6AF9DDF87B37BBE6E83F5DF2B8F5B86F98F12F5E</code>. This key is also available on MIT's Key Server and reproduced below.</p> <p>After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours.</p>"},{"location":"security/#disclosure-policy","title":"Disclosure Policy","text":"<p><code>wraps-core</code> has a 5-step disclosure process:</p> <ol> <li> <p>The security report is received and is assigned a primary handler.    This person will coordinate the fix and release process.</p> </li> <li> <p>The problem is confirmed and a list of all affected versions is determined.</p> </li> <li> <p>Code is audited to find any potential similar problems.</p> </li> <li> <p>Fixes are prepared for all releases which are still under maintenance.    These fixes are not committed to the public repository but rather    held locally pending the announcement.</p> </li> <li> <p>On the embargo date, the changes are pushed to the public repository    and new builds are deployed.</p> </li> </ol> <p>This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner.</p>"},{"location":"security/#security-key","title":"Security Key","text":"<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmQINBGVV4JcBEAC7PTswfzA2iMTVSig51NVDV08XABrR01qslTfhIVw6Uwr2iCoY\nF+hkNn3++pgoF95Fx/iREDFV/AG4GGKl1GbAI3YD6aOoh0FGWtxg3MMa3oHjRUZs\nf0VwKk8sA5d21V05OiMuptAqxXuLrdR5SINtxKE10H6K9o22988VOmWUCIEaxKM5\nM5HCfhe8fl5pKpdIf3i1F073qset4DXGkvm/v+dWYHPvv0NlHhnJ5Lcaq4aTvkEg\ny2NhDobR4VpdP1aQZbEONussUaKLxBTBJN5NNnf7SI1qVYcaglYrXM7uQGXuL32X\nXAILtOCM0LO2059Z7ZMkI6lkkbei1j08j2Tha/1GvN2rIClNyV912GvAQhzlwhdT\nWmk+ymrwbed7MkRW3IB3b1zFb7Dhz6a5yBS8iT5ikkrGaR/i7O3V/DS02j7Rao2k\nnfXIncuBuXSXb1pIhCuYuV6VYBgFWfpKDjOzEy83h3DSI/jrR31e6aiBes+fyFRG\nIuoFRTsaMq2T9M5F6pDvmtoexHxXevYoSt+7DURY1pSWnk4MjZUj7yDFPSyfPleZ\naNq/3aGQt7vnY5QgyGjKaX5jSVuNEKsUlhrKUWt9weoJrF5ZyYHY0RPg1q1Fz0mY\nZ7QWeaKA0uOeziG0bHf6yNEzxnaYCfi09/WOL4GH0pBsdubNHpWno/D6PwARAQAB\ntC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2\nPokCTgQTAQoAOBYhBGr53fh7N7vm6D9d8rj1uG+Y8S9eBQJlVeCXAhsDBQsJCAcC\nBhUKCQgLAgQWAgMBAh4BAheAAAoJELj1uG+Y8S9ed4kP+wYE1OZtcWoRSK2Xqvaf\nP5+YcXC1vdCZ16depb6kGOR91G9eEMJhSDlSzzUzOmkvT4TknZi/Y17m9TvQccET\nSwgWvDs9XwMby24mkxD1iYu2uIZXXhRbIKJPi4EpGgamEveYLLTd0L8yX2l/YXuq\nVcM4vqgRtnovlW+cCUmmtpRcb+Ldfxu2RixjnG4fznzzlMOnU0zpWUMBqH+mSyfH\nRmY5vgOR/adgQcIviQdhRPMC4TAa3GNdTd2Qpxo3xelum15yLKxkm/EvBSPsL1fj\nJQBYnZFk4KBKNiXXYwWuU0mpOx1TMtYPVnHer17QL0vXfsmVNkXVzucvrNfHpFc9\nhXzmm5wHwMrGClyQBA6sDWDfQOKYibQTcKzyJr2Gl31luNPSRchzC4lbosLzRkqh\nYh5dco+ITiKDe7g54w+Fy+KdumwN/GvBlQptGIpaxA1+xAbNVs+fDo+WrQEL+AZO\nOQR91YUsjIdvVdk5BcgUYvEe2YyyMZ7LSqWACpRknqz5FNcdmO2bz7jl732EYLRm\nQ90oSG6xcIFuPZRNVIUJds9Gg2u1PBV5z0vnFGiJ6NK6DrYYecMKU9uAQUZcSW8v\n+fn92V0DkVeOfeMbq4yytZx5W4VrsWT1XyfjTzg867jzmo1JmZQeZ4KXh7AYRlC6\nn8NwYZ13+pUFeTPm9jCwJMrGuQINBGVV4JcBEACg5zXucth9KIdryYUxyBgA7Ist\nhJmyxtSHSiKRFOiQBmQqHeQgDdCnBeDw+cb+8wB4NL3PNw5xHKRvQGTWaBTV1IPf\nCV3P2c/sZLDCU8PNMu3lsmEbN2ippOiJi1fw478EGlNity8ktI+TEhsdniypKoiw\nDNf3wdawWiraODM9KuYplcsnFHl5r97BjHR0EbOOKkTc4PwysQ7WVHZ/nwGzNb5T\nCI7A/TF0RTL/Wkdz7WZM7r5BELz+z0ksjsS8eMObtm/uG4lfAmbIGohPTlir4WWL\n/GYZpAjvv/6zNaydMpY3uQKrdqN05j10uYnkbsclwSBBbRovFBRWEInbO0cqpzc0\nJiWt4U91F6UNbSDPo3KaiDjJXDb7cr4gQv0C1T9LtmKSfY/JVcUj7csGXslOAvXf\nz08iDCJu3zj7QjZPKA1/MxmTo88hAvhHlOYrXaaRjzXt6r9+qdDxVYJGe9K3LkJS\n9Yc0U9xBGAfzw9Ebs/ZPDtjgupPHJXq6VBSndU3c53jr7SEZBIFMPg75CeJJ6IgH\nA4zwW1uzalZi3mYWWCKiGhDBPOo5yGwKocxMzSuerlMW21fjhOMymSKVksteJlmZ\nAy6ExDNOK663V6iFnsn4iIFbE1jOznHhSsbyKqQ/QukpMqAyrQVSNyutXVl0VuW0\nZsZeFff7ScnrTgB7/QARAQABiQI2BBgBCgAgFiEEavnd+Hs3u+boP13yuPW4b5jx\nL14FAmVV4JcCGwwACgkQuPW4b5jxL15jNw/9EQkahEieTABEKAKxGetODA7HTiNR\ncM3aKgDU0msYjfgfAi+wQzx/8k8Yf/Kjma6JqsksCj0ygFkXS87tOAUfJTpgmKVS\nV3XaDXFwTcdG0+/Cx5RllduJmnLTLSuvm2uxu7ErPGtnYWBw88nmQ/8f9nkmvCsY\nCuF6DHAUNzTLgerFKSGNMwOv6kKBCgNkstclcHp5YbzssN1w34dPV/swuCjc+6JM\nnW5WuPD3R2Y9522Ov/bEwr9raFf3R5A6ETK4GOZUqNmPG4MJgbyiJlk96TuF06mO\nnFpKnBtxD+t20jAFTMRokyiQT65X8KnrpT8CpTJ6xzmBO5IYGhUSqt3CH/YzwqRa\nv9FTJ/qSPM5OXPH4pK7VzNDVhEPQhLAGENLwOnasnXXGvj/MQIRYyjGAXQfB34a7\nz0x4rQ+fyaody6BW10KJBQuRrB3dPaOPU3LU/4TxzyudDxiOJGiWAlw56a2lviEG\nJExMJrSvP5kiCfPlLZiLfqaw2ZYeyosnv8bmC4H2Sr9IEggtCyrzNOoJQx+w/f/L\n6a14Cshc3UYLC+0yh74Mc5vUu2SfwI6zSevjI1LWj4qc592J/q3QNHiJN9F60tyP\nr46uNM25Y+C5qgVneqRjHmWSIdOvYXcBTLj03eDiQHCJz3ZT6ztLwQxQ800MS1Yd\npbmAGLbBB2TBok4=\n=Ir8m\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"security/#attribution","title":"Attribution","text":"<p>This Security Policy is adapted from Rust's Security Policy.</p>"},{"location":"reference/either/","title":"Either","text":"<p>Either values.</p> <p>The <code>Either[L, R]</code> type is symmetric and treats its variants the same way, without preference. For representing results (values and errors), use the <code>Result[T, E]</code> instead.</p>"},{"location":"reference/either/#wraps_core.either.Either","title":"<code>Either = Union[Left[L], Right[R]]</code>  <code>module-attribute</code>","text":"<p>Either value, expressed as the union of <code>Left[L]</code> and <code>Right[R]</code>.</p>"},{"location":"reference/either/#wraps_core.either.Left","title":"<code>Left</code>","text":"<p>               Bases: <code>EitherProtocol[L, Never]</code></p> <p><code>Left[L]</code> variant of <code>Either[L, R]</code>.</p> Source code in <code>src/wraps_core/either.py</code> <pre><code>@final\n@frozen()\nclass Left(EitherProtocol[L, Never]):\n    \"\"\"[`Left[L]`][wraps_core.either.Left] variant of [`Either[L, R]`][wraps_core.either.Either].\"\"\"\n\n    value: L\n\n    def __repr__(self) -&gt; str:\n        return wrap_repr(self, self.value)\n\n    @classmethod\n    def create(cls, value: M) -&gt; Left[M]:\n        return cls(value)  # type: ignore[arg-type, return-value]\n\n    def is_left(self) -&gt; Literal[True]:\n        return True\n\n    def is_left_and(self, predicate: Predicate[L]) -&gt; bool:\n        return predicate(self.value)\n\n    async def is_left_and_await(self, predicate: AsyncPredicate[L]) -&gt; bool:\n        return await predicate(self.value)\n\n    def is_right(self) -&gt; Literal[False]:\n        return False\n\n    def is_right_and(self, predicate: Predicate[R]) -&gt; Literal[False]:\n        return False\n\n    async def is_right_and_await(self, predicate: AsyncPredicate[R]) -&gt; Literal[False]:\n        return False\n\n    def left(self) -&gt; Some[L]:\n        return Some(self.value)\n\n    def left_or(self, default: L) -&gt; L:  # type: ignore[misc]\n        return self.value\n\n    def left_or_else(self, default: Nullary[L]) -&gt; L:\n        return self.value\n\n    async def left_or_else_await(self, default: AsyncNullary[L]) -&gt; L:\n        return self.value\n\n    def right(self) -&gt; Null:\n        return NULL\n\n    def right_or(self, default: R) -&gt; R:  # type: ignore[misc]\n        return default\n\n    def right_or_else(self, default: Nullary[R]) -&gt; R:\n        return default()\n\n    async def right_or_else_await(self, default: AsyncNullary[R]) -&gt; R:\n        return await default()\n\n    def expect_left(self, message: str) -&gt; L:\n        return self.value\n\n    def expect_right(self, message: str) -&gt; Never:\n        panic(message)\n\n    def unwrap_left(self) -&gt; L:\n        return self.value\n\n    def unwrap_right(self) -&gt; Never:\n        panic(UNWRAP_RIGHT_ON_LEFT)\n\n    def into_either(self: Left[T]) -&gt; T:\n        return self.value\n\n    def inspect_left(self, function: Inspect[L]) -&gt; Left[L]:\n        function(self.value)\n\n        return self\n\n    def inspect_right(self, function: Inspect[R]) -&gt; Left[L]:\n        return self\n\n    async def inspect_left_await(self, function: AsyncInspect[L]) -&gt; Left[L]:\n        await function(self.value)\n\n        return self\n\n    async def inspect_right_await(self, function: AsyncInspect[R]) -&gt; Left[L]:\n        return self\n\n    def flip(self) -&gt; Right[L]:\n        return Right(self.value)\n\n    def map_left(self, function: Unary[L, M]) -&gt; Left[M]:\n        return self.create(function(self.value))\n\n    async def map_left_await(self, function: AsyncUnary[L, M]) -&gt; Left[M]:\n        return self.create(await function(self.value))\n\n    def map_right(self, function: Unary[R, S]) -&gt; Left[L]:\n        return self\n\n    async def map_right_await(self, function: AsyncUnary[R, S]) -&gt; Left[L]:\n        return self\n\n    def map(self: Left[T], function: Unary[T, U]) -&gt; Left[U]:\n        return self.create(function(self.value))\n\n    async def map_await(self: Left[T], function: AsyncUnary[T, U]) -&gt; Left[U]:\n        return self.create(await function(self.value))\n\n    def map_either(self, left: Unary[L, M], right: Unary[R, S]) -&gt; Left[M]:\n        return self.create(left(self.value))\n\n    async def map_either_await(self, left: AsyncUnary[L, M], right: Unary[R, S]) -&gt; Left[M]:\n        return self.create(await left(self.value))\n\n    def either(self, left: Unary[L, T], right: Unary[R, T]) -&gt; T:\n        return left(self.value)\n\n    async def either_await(self, left: AsyncUnary[L, T], right: AsyncUnary[R, T]) -&gt; T:\n        return await left(self.value)\n\n    def left_and_then(self, function: Unary[L, Either[M, R]]) -&gt; Either[M, R]:\n        return function(self.value)\n\n    async def left_and_then_await(self, function: AsyncUnary[L, Either[M, R]]) -&gt; Either[M, R]:\n        return await function(self.value)\n\n    def right_and_then(self, function: Unary[R, Either[L, S]]) -&gt; Left[L]:\n        return self\n\n    async def right_and_then_await(self, function: AsyncUnary[R, Either[L, S]]) -&gt; Left[L]:\n        return self\n\n    def iter_left(self) -&gt; Iterator[L]:\n        return once(self.value)\n\n    def iter_right(self) -&gt; Iterator[Never]:\n        return empty()\n\n    def iter_either(self: Left[T]) -&gt; Iterator[T]:\n        return once(self.value)\n\n    def async_iter_left(self) -&gt; AsyncIterator[L]:\n        return async_once(self.value)\n\n    def async_iter_right(self) -&gt; AsyncIterator[Never]:\n        return async_empty()\n\n    def async_iter_either(self: Left[T]) -&gt; AsyncIterator[T]:\n        return async_once(self.value)\n\n    def contains_left(self, value: M) -&gt; bool:\n        return self.value == value\n\n    def contains_right(self, value: S) -&gt; Literal[False]:\n        return False\n\n    def contains(self: Left[T], value: U) -&gt; bool:\n        return self.value == value\n\n    def into_result(self) -&gt; Ok[L]:\n        return Ok(self.value)\n</code></pre>"},{"location":"reference/either/#wraps_core.either.Right","title":"<code>Right</code>","text":"<p>               Bases: <code>EitherProtocol[Never, R]</code></p> <p><code>Right[R]</code> variant of <code>Either[L, R]</code>.</p> Source code in <code>src/wraps_core/either.py</code> <pre><code>@final\n@frozen()\nclass Right(EitherProtocol[Never, R]):\n    \"\"\"[`Right[R]`][wraps_core.either.Right] variant of [`Either[L, R]`][wraps_core.either.Either].\"\"\"\n\n    value: R\n\n    def __repr__(self) -&gt; str:\n        return wrap_repr(self, self.value)\n\n    @classmethod\n    def create(cls, value: S) -&gt; Right[S]:\n        return cls(value)  # type: ignore[arg-type, return-value]\n\n    def is_left(self) -&gt; Literal[False]:\n        return False\n\n    def is_left_and(self, predicate: Predicate[L]) -&gt; Literal[False]:\n        return False\n\n    async def is_left_and_await(self, predicate: AsyncPredicate[L]) -&gt; Literal[False]:\n        return False\n\n    def is_right(self) -&gt; Literal[True]:\n        return True\n\n    def is_right_and(self, predicate: Predicate[R]) -&gt; bool:\n        return predicate(self.value)\n\n    async def is_right_and_await(self, predicate: AsyncPredicate[R]) -&gt; bool:\n        return await predicate(self.value)\n\n    def left(self) -&gt; Null:\n        return NULL\n\n    def left_or(self, default: L) -&gt; L:  # type: ignore[misc]\n        return default\n\n    def left_or_else(self, default: Nullary[L]) -&gt; L:\n        return default()\n\n    async def left_or_else_await(self, default: AsyncNullary[L]) -&gt; L:\n        return await default()\n\n    def right(self) -&gt; Some[R]:\n        return Some(self.value)\n\n    def right_or(self, default: R) -&gt; R:  # type: ignore[misc]\n        return self.value\n\n    def right_or_else(self, default: Nullary[R]) -&gt; R:\n        return self.value\n\n    async def right_or_else_await(self, default: AsyncNullary[R]) -&gt; R:\n        return self.value\n\n    def expect_left(self, message: str) -&gt; Never:\n        panic(message)\n\n    def expect_right(self, message: str) -&gt; R:\n        return self.value\n\n    def unwrap_left(self) -&gt; Never:\n        panic(UNWRAP_LEFT_ON_RIGHT)\n\n    def unwrap_right(self) -&gt; R:\n        return self.value\n\n    def into_either(self: Right[T]) -&gt; T:\n        return self.value\n\n    def inspect_left(self, function: Inspect[L]) -&gt; Right[R]:\n        return self\n\n    def inspect_right(self, function: Inspect[R]) -&gt; Right[R]:\n        function(self.value)\n\n        return self\n\n    async def inspect_left_await(self, function: AsyncInspect[L]) -&gt; Right[R]:\n        return self\n\n    async def inspect_right_await(self, function: AsyncInspect[R]) -&gt; Right[R]:\n        await function(self.value)\n\n        return self\n\n    def flip(self) -&gt; Left[R]:\n        return Left(self.value)\n\n    def map_left(self, function: Unary[L, M]) -&gt; Right[R]:\n        return self\n\n    async def map_left_await(self, function: AsyncUnary[L, M]) -&gt; Right[R]:\n        return self\n\n    def map_right(self, function: Unary[R, S]) -&gt; Right[S]:\n        return self.create(function(self.value))\n\n    async def map_right_await(self, function: AsyncUnary[R, S]) -&gt; Right[S]:\n        return self.create(await function(self.value))\n\n    def map(self: Right[T], function: Unary[T, U]) -&gt; Right[U]:\n        return self.create(function(self.value))\n\n    async def map_await(self: Right[T], function: AsyncUnary[T, U]) -&gt; Right[U]:\n        return self.create(await function(self.value))\n\n    def map_either(self, left: Unary[L, M], right: Unary[R, S]) -&gt; Right[S]:\n        return self.create(right(self.value))\n\n    async def map_either_await(self, left: AsyncUnary[L, M], right: AsyncUnary[R, S]) -&gt; Right[S]:\n        return self.create(await right(self.value))\n\n    def either(self, left: Unary[L, T], right: Unary[R, T]) -&gt; T:\n        return right(self.value)\n\n    async def either_await(self, left: AsyncUnary[L, T], right: AsyncUnary[R, T]) -&gt; T:\n        return await right(self.value)\n\n    def left_and_then(self, function: Unary[L, Either[M, R]]) -&gt; Right[R]:\n        return self\n\n    async def left_and_then_await(self, function: AsyncUnary[L, Either[M, R]]) -&gt; Right[R]:\n        return self\n\n    def right_and_then(self, function: Unary[R, Either[L, S]]) -&gt; Either[L, S]:\n        return function(self.value)\n\n    async def right_and_then_await(self, function: AsyncUnary[R, Either[L, S]]) -&gt; Either[L, S]:\n        return await function(self.value)\n\n    def iter_left(self) -&gt; Iterator[Never]:\n        return empty()\n\n    def iter_right(self) -&gt; Iterator[R]:\n        return once(self.value)\n\n    def iter_either(self: Right[T]) -&gt; Iterator[T]:\n        return once(self.value)\n\n    def async_iter_left(self) -&gt; AsyncIterator[Never]:\n        return async_empty()\n\n    def async_iter_right(self) -&gt; AsyncIterator[R]:\n        return async_once(self.value)\n\n    def async_iter_either(self: Right[T]) -&gt; AsyncIterator[T]:\n        return async_once(self.value)\n\n    def contains_left(self, value: M) -&gt; Literal[False]:\n        return False\n\n    def contains_right(self, value: S) -&gt; bool:\n        return self.value == value\n\n    def contains(self: Right[T], value: U) -&gt; bool:\n        return self.value == value\n\n    def into_result(self) -&gt; Error[R]:\n        return Error(self.value)\n</code></pre>"},{"location":"reference/errors/","title":"Errors","text":""},{"location":"reference/errors/#wraps_core.errors.RawErrorTypes","title":"<code>RawErrorTypes = DynamicTuple[Type[E]]</code>  <code>module-attribute</code>","text":"<p>Represents error types. <code>E</code> is bound to <code>AnyError</code>.</p>"},{"location":"reference/errors/#wraps_core.errors.ErrorTypes","title":"<code>ErrorTypes</code>","text":"<p>               Bases: <code>Generic[E]</code></p> <p>Represents non-empty error types. <code>E</code> is bound to <code>AnyError</code>.</p> Source code in <code>src/wraps_core/errors.py</code> <pre><code>@final\n@frozen()\nclass ErrorTypes(Generic[E]):\n    \"\"\"Represents non-empty error types. `E` is bound to [`AnyError`][typing_aliases.AnyError].\"\"\"\n\n    raw: RawErrorTypes[E] = field()\n    \"\"\"Raw error types.\"\"\"\n\n    @raw.validator\n    def check_raw(self, attribute: Attribute[RawErrorTypes[E]], value: RawErrorTypes[E]) -&gt; None:\n        if is_empty_tuple(value):\n            panic(expected_error_types(value))\n\n    @classmethod\n    def from_head_and_tail(cls, head: Type[E], *tail: Type[E]) -&gt; Self:\n        raw = (head, *tail)\n\n        return cls(raw)\n\n    def extract(self) -&gt; RawErrorTypes[E]:\n        return self.raw\n</code></pre>"},{"location":"reference/errors/#wraps_core.errors.ErrorTypes.raw","title":"<code>raw: RawErrorTypes[E] = field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Raw error types.</p>"},{"location":"reference/markers/","title":"Markers","text":"<p>Various markers.</p>"},{"location":"reference/markers/#wraps_core.markers.UNREACHABLE","title":"<code>UNREACHABLE = 'code marked as `unreachable` was reached'</code>  <code>module-attribute</code>","text":"<p>The default <code>unreachable</code> panic message.</p>"},{"location":"reference/markers/#wraps_core.markers.unreachable","title":"<code>unreachable(message: Optional[str] = None) -&gt; Never</code>","text":"<p>Marks points in code as unreachable.</p> <p>Panics with the message given. If not provided, <code>UNREACHABLE</code> is used.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>The message to panic with.</p> <code>None</code> <p>Raises:</p> Type Description <code>Panic</code> <p>Always raised when calling.</p> Source code in <code>src/wraps_core/markers.py</code> <pre><code>def unreachable(message: Optional[str] = None) -&gt; Never:\n    \"\"\"Marks points in code as unreachable.\n\n    Panics with the message given. If not provided,\n    [`UNREACHABLE`][wraps_core.markers.UNREACHABLE] is used.\n\n    Arguments:\n        message: The message to panic with.\n\n    Raises:\n        Panic: Always raised when calling.\n    \"\"\"\n    if message is None:\n        message = UNREACHABLE\n\n    panic(message)\n</code></pre>"},{"location":"reference/option/","title":"Option","text":"<p>Optional values.</p> <p><code>Option[T]</code> represents an optional value: every <code>Option[T]</code> is either <code>Some[T]</code> and contains a value, or <code>Null</code>, and does not.</p> <p><code>Option[T]</code> types can be very common in python code, as they have a number of uses:</p> <ul> <li>Initial values (see <code>ReAwaitable[T]</code>);</li> <li>Return values for functions not defined over their entire input range (partial functions);</li> <li>Return value for otherwise reporting simple errors, where <code>Null</code>   is returned on error;</li> <li>Optional function arguments (albeit slightly unergonomic).</li> </ul> <p><code>Option[T]</code> is commonly paired with pattern matching to query the presence of <code>Some[T]</code> value (<code>T</code>) and take action, always accounting for the <code>Null</code> case:</p> <pre><code># option.py\n\nfrom wraps import NULL, Option, Some\n\n\ndef divide(numerator: float, denominator: float) -&gt; Option[float]:\n    return Some(numerator / denominator) if denominator else NULL\n</code></pre> <pre><code>from wraps import Null, Some\n\nfrom option import divide\n\nDIVISION_BY_ZERO = \"division by zero\"\n\nmatch divide(1.0, 2.0):\n    case Some(result):\n        print(result)\n\n    case Null():\n        print(DIVISION_BY_ZERO)\n</code></pre> <p>Here, we know that <code>Null</code> represents only one case, that is, attempts to divide by zero. However, when we need to represent multiple errors from one function, we might want to use <code>Result[T, E]</code> instead, as described in the <code>result</code> section.</p>"},{"location":"reference/option/#wraps_core.option.Option","title":"<code>Option = Union[Some[T], Null]</code>  <code>module-attribute</code>","text":"<p>Optional value, expressed as the union of <code>Some[T]</code> and <code>Null</code>.</p>"},{"location":"reference/option/#wraps_core.option.NULL","title":"<code>NULL = Null()</code>  <code>module-attribute</code>","text":"<p>The instance of <code>Null</code>.</p>"},{"location":"reference/option/#wraps_core.option.wrap_option","title":"<code>wrap_option = wrap_option_on(NormalError)</code>  <code>module-attribute</code>","text":"<p>An instance of <code>WrapOption[NormalError]</code> (see <code>NormalError</code>).</p>"},{"location":"reference/option/#wraps_core.option.wrap_option_await","title":"<code>wrap_option_await = wrap_option_await_on(NormalError)</code>  <code>module-attribute</code>","text":"<p>An instance of <code>WrapOptionAwait[NormalError]</code> (see <code>NormalError</code>).</p>"},{"location":"reference/option/#wraps_core.option.OptionProtocol","title":"<code>OptionProtocol</code>","text":"<p>               Bases: <code>AsyncIterable[T]</code>, <code>Iterable[T]</code>, <code>Protocol[T]</code></p> Source code in <code>src/wraps_core/option.py</code> <pre><code>class OptionProtocol(AsyncIterable[T], Iterable[T], Protocol[T]):  # type: ignore[misc]\n    def __iter__(self) -&gt; Iterator[T]:\n        return self.iter()\n\n    def __aiter__(self) -&gt; AsyncIterator[T]:\n        return self.async_iter()\n\n    @required\n    def is_some(self) -&gt; bool:\n        \"\"\"Checks if the option is [`Some[T]`][wraps_core.option.Some].\n\n        Example:\n            ```python\n            some = Some(42)\n            assert some.is_some()\n\n            null = NULL\n            assert not null.is_some()\n            ```\n\n        Returns:\n            Whether the option is [`Some[T]`][wraps_core.option.Some].\n        \"\"\"\n        ...\n\n    @required\n    def is_some_and(self, predicate: Predicate[T]) -&gt; bool:\n        \"\"\"Checks if the option is [`Some[T]`][wraps_core.option.Some] and the value\n        inside of it matches the `predicate`.\n\n        Example:\n            ```python\n            def is_positive(value: int) -&gt; bool:\n                return value &gt; 0\n\n            some = Some(13)\n            assert some.is_some_and(is_positive)\n\n            zero = Some(0)\n            assert not zero.is_some_and(is_positive)\n\n            null = NULL\n            assert not null.is_some_and(is_positive)\n            ```\n\n        Arguments:\n            predicate: The predicate to check the possibly contained value against.\n\n        Returns:\n            Whether the option is [`Some[T]`][wraps_core.option.Some] and the predicate is matched.\n        \"\"\"\n        ...\n\n    @required\n    async def is_some_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n        \"\"\"Checks if the option is [`Some[T]`][wraps_core.option.Some] and the value\n        inside of it matches the asynchronous `predicate`.\n\n        Example:\n            ```python\n            async def is_negative(value: int) -&gt; bool:\n                return value &lt; 0\n\n            some = Some(-42)\n            assert await some.is_some_and_await(is_negative)\n\n            zero = Some(0)\n            assert not await zero.is_some_and_await(is_negative)\n\n            null = NULL\n            assert not await null.is_some_and_await(is_negative)\n            ```\n\n        Arguments:\n            predicate: The asynchronous predicate to check the possibly contained value against.\n\n        Returns:\n            Whether the option is [`Some[T]`][wraps_core.option.Some] and\n            the asynchronous predicate is matched.\n        \"\"\"\n        ...\n\n    @required\n    def is_null(self) -&gt; bool:\n        \"\"\"Checks if the option is [`Null`][wraps_core.option.Null].\n\n        Example:\n            ```python\n            null = NULL\n            assert null.is_null()\n\n            some = Some(34)\n            assert not some.is_null()\n            ```\n\n        Returns:\n            Whether the option is [`Null`][wraps_core.option.Null].\n        \"\"\"\n        ...\n\n    @required\n    def expect(self, message: str) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; some = Some(42)\n            &gt;&gt;&gt; some.expect(\"panic!\")\n            42\n            &gt;&gt;&gt; null = NULL\n            &gt;&gt;&gt; null.expect(\"panic!\")\n            Traceback (most recent call last):\n              ...\n            wraps_core.panics.Panic: panic!\n            ```\n\n        Arguments:\n            message: The message to use in panicking.\n\n        Raises:\n            Panic: Panics with the `message` if the option is [`Null`][wraps_core.option.Null].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def extract(self) -&gt; Optional[T]:\n        \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value or [`None`][None].\n\n        Example:\n            ```python\n            &gt;&gt;&gt; some = Some(42)\n            &gt;&gt;&gt; some.extract()\n            42\n            &gt;&gt;&gt; null = NULL\n            &gt;&gt;&gt; null.extract()\n            &gt;&gt;&gt; # None\n            ```\n\n        Returns:\n            The contained value or [`None`][None].\n        \"\"\"\n        ...\n\n    @required\n    def unwrap(self) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value.\n\n        Because this function may panic, its use is generally discouraged.\n\n        Instead, prefer to use pattern matching and handle the [`Null`][wraps_core.option.Null]\n        case explicitly, or call [`unwrap_or`][wraps_core.option.OptionProtocol.unwrap_or]\n        or [`unwrap_or_else`][wraps_core.option.OptionProtocol.unwrap_or_else].\n\n        Example:\n            ```python\n            &gt;&gt;&gt; some = Some(42)\n            &gt;&gt;&gt; some.unwrap()\n            42\n            &gt;&gt;&gt; null = NULL\n            &gt;&gt;&gt; null.unwrap()\n            Traceback (most recent call last):\n              ...\n            wraps_core.panics.Panic: called `unwrap` on null\n            ```\n\n        Raises:\n            Panic: Panics if the option is [`Null`][wraps_core.option.Null].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_or(self, default: T) -&gt; T:  # type: ignore[misc]\n        \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value or the provided `default`.\n\n        Example:\n            ```python\n            some = Some(13)\n            assert some.unwrap_or(0)\n\n            null = NULL\n            assert not null.unwrap_or(0)\n            ```\n\n        Arguments:\n            default: The default value to use.\n\n        Returns:\n            The contained value or the `default` one.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_or_else(self, default: Nullary[T]) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value or\n        computes it from the `default` function.\n\n        Example:\n            ```python\n            some = Some(13)\n            assert some.unwrap_or_else(int)\n\n            null = NULL\n            assert not null.unwrap_or_else(int)\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n\n        Returns:\n            The contained value or the `default()` one.\n        \"\"\"\n        ...\n\n    @required\n    async def unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value\n        or computes it from the asynchronous `default` function.\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 0\n\n            some = Some(42)\n            assert await some.unwrap_or_else_await(default)\n\n            null = NULL\n            assert not await null.unwrap_or_else_await(default)\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n\n        Returns:\n            The contained value or the `await default()` one.\n        \"\"\"\n        ...\n\n    @required\n    def or_raise(self, error: AnyError) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value\n        or raises the `error` provided.\n\n        Arguments:\n            error: The error to raise if the option is [`Null`][wraps_core.option.Null].\n\n        Raises:\n            AnyError: The error provided, if the option is [`Null`][wraps_core.option.Null].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value\n        or raises the error computed from `error`.\n\n        Arguments:\n            error: The error to raise if the option is [`Null`][wraps_core.option.Null].\n\n        Raises:\n            AnyError: The error computed, if the option is [`Null`][wraps_core.option.Null].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    async def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value\n        or raises the error computed asynchronously from `error`.\n\n        Arguments:\n            error: The error to raise if the option is [`Null`][wraps_core.option.Null].\n\n        Raises:\n            AnyError: The error computed, if the option is [`Null`][wraps_core.option.Null].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def inspect(self, function: Inspect[T]) -&gt; Option[T]:\n        \"\"\"Inspects a possibly contained [`Option[T]`][wraps_core.option.Option] value.\n\n        Example:\n            ```python\n            some = Some(\"Hello, world!\")\n\n            same = some.inspect(print)  # Hello, world!\n\n            assert some == same\n            ```\n\n        Arguments:\n            function: The inspecting function.\n\n        Returns:\n            The inspected option.\n        \"\"\"\n        ...\n\n    @required\n    async def inspect_await(self, function: AsyncInspect[T]) -&gt; Option[T]:\n        \"\"\"Inspects a possibly contained [`Option[T]`][wraps_core.option.Option] value.\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; None:\n                print(value)\n\n            some = Some(\"Hello, world!\")\n\n            same = await some.inspect(function)  # Hello, world!\n\n            assert some == same\n            ```\n\n        Arguments:\n            function: The asynchronous inspecting function.\n\n        Returns:\n            The inspected option.\n        \"\"\"\n        ...\n\n    @required\n    def map(self, function: Unary[T, U]) -&gt; Option[U]:\n        \"\"\"Maps an [`Option[T]`][wraps_core.option.Option] to an [`Option[U]`][wraps_core.option.Option]\n        by applying the `function` to the contained value.\n\n        Example:\n            ```python\n            some = Some(\"Hello, world!\")\n\n            print(some.map(len).unwrap())  # 13\n            ```\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The mapped option.\n        \"\"\"\n        ...\n\n    @required\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        \"\"\"Returns the `default` value (if none), or applies the `function`\n        to the contained value (if any).\n\n        Example:\n            ```python\n            some = Some(\"nekit\")\n\n            print(some.map_or(42, len))  # 5\n\n            null = NULL\n\n            print(null.map_or(42, len))  # 42\n            ```\n\n        Arguments:\n            default: The default value to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting value or the `default` one.\n        \"\"\"\n        ...\n\n    @required\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        \"\"\"Computes the default value from the `default` function (if none),\n        or applies the `function` to the contained value (if any).\n\n        Example:\n            ```python\n            def default() -&gt; int:\n                return 42\n\n            some = Some(\"Hello, world!\")\n\n            print(some.map_or_else(default, len))  # 13\n\n            null = NULL\n\n            print(null.map_or_else(default, len))  # 42\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting value or the `default()` one.\n        \"\"\"\n        ...\n\n    @required\n    async def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        \"\"\"Computes the default value from the asynchronous `default` function (if none),\n        or applies the `function` to the contained value (if any).\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 42\n\n            some = Some(\"Hello, world!\")\n\n            print(await some.map_or_else_await(default, len))  # 13\n\n            null = NULL\n\n            print(await null.map_or_else_await(default, len))  # 42\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting value or the `await default()` one.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await(self, function: AsyncUnary[T, U]) -&gt; Option[U]:\n        \"\"\"Maps an [`Option[T]`][wraps_core.option.Option] to an [`Option[U]`][wraps_core.option.Option]\n        by applying the asynchronous `function` to the contained value.\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            some = Some(\"Hello, world!\")\n\n            mapped = await some.map_await(function)\n\n            print(some.unwrap())  # 13\n            ```\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The mapped option.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        \"\"\"Returns the `default` value (if none), or applies the asynchronous `function`\n        to the contained value (if any).\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            some = Some(\"nekit\")\n\n            print(await some.map_await_or(42, function))  # 5\n\n            null = NULL\n\n            print(await null.map_await_or(42, function))  # 42\n            ```\n\n        Arguments:\n            default: The default value to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting value or the `default` one.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        \"\"\"Computes the default value from the `default` function (if none),\n        or applies the asynchronous `function` to the contained value (if any).\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            def default() -&gt; int:\n                return 0\n\n            some = Some(\"Hello, world!\")\n\n            print(await some.map_await_or_else(default, function))  # 13\n\n            null = NULL\n\n            print(await null.map_await_or_else(default, function))  # 0\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting value or the `default()` one.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        \"\"\"Computes the default value (if none), or applies the asynchronous `function`\n        to the contained value (if any).\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 42\n\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            some = Some(\"Hello, world!\")\n\n            print(await some.map_await_or_else_await(default, function))  # 13\n\n            null = NULL\n\n            print(await null.map_await_or_else_await(default, function))  # 42\n            ```\n\n        Arguments:\n            default: The asynchronous default function to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting value or the `await default()` one.\n        \"\"\"\n        ...\n\n    @required\n    def ok_or(self, error: E) -&gt; Result[T, E]:\n        \"\"\"Transforms an [`Option[T]`][wraps_core.option.Option]\n        into a [`Result[T, E]`][wraps_core.result.Result], mapping [`Some(value)`][wraps_core.option.Some]\n        to [`Ok(value)`][wraps_core.result.Ok] and [`Null`][wraps_core.option.Null]\n        to [`Error(error)`][wraps_core.result.Error].\n\n        Example:\n            ```python\n            error = Error(13)\n\n            some = Some(42)\n            assert some.ok_or(error).is_ok()\n\n            null = NULL\n            assert null.ok_or(error).is_error()\n            ```\n\n        Arguments:\n            error: The error to use.\n\n        Returns:\n            The transformed result.\n        \"\"\"\n        ...\n\n    @required\n    def ok_or_else(self, error: Nullary[E]) -&gt; Result[T, E]:\n        \"\"\"Transforms an [`Option[T]`][wraps_core.option.Option]\n        into a [`Result[T, E]`][wraps_core.result.Result], mapping [`Some(value)`][wraps_core.option.Some]\n        to [`Ok(value)`][wraps_core.result.Ok] and [`Null`][wraps_core.option.Null]\n        to [`Error(error())`][wraps_core.result.Error].\n\n        Example:\n            ```python\n            def error() -&gt; Error[int]:\n                return Error(0)\n\n            some = Some(7)\n            assert some.ok_or_else(error).is_ok()\n\n            null = NULL\n            assert null.ok_or_else(error).is_error()\n            ```\n\n        Arguments:\n            error: The error-computing function to use.\n\n        Returns:\n            The transformed result.\n        \"\"\"\n        ...\n\n    @required\n    async def ok_or_else_await(self, error: AsyncNullary[E]) -&gt; Result[T, E]:\n        \"\"\"Transforms an [`Option[T]`][wraps_core.option.Option]\n        into a [`Result[T, E]`][wraps_core.result.Result], mapping [`Some(value)`][wraps_core.option.Some]\n        to [`Ok(value)`][wraps_core.result.Ok] and [`Null`][wraps_core.option.Null]\n        to [`Error(await error())`][wraps_core.result.Error].\n\n        Example:\n            ```python\n            async def error() -&gt; Error[int]:\n                return Error(0)\n\n            some = Some(7)\n            result = await some.ok_or_else_await(error)\n\n            assert result.is_ok()\n\n            null = NULL\n            result = await null.ok_or_else_await(error)\n\n            assert result.is_error()\n            ```\n\n        Arguments:\n            error: The error-computing function to use.\n\n        Returns:\n            The transformed result.\n        \"\"\"\n        ...\n\n    @required\n    def iter(self) -&gt; Iterator[T]:\n        \"\"\"Returns an iterator over the possibly contained value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; some = Some(42)\n            &gt;&gt;&gt; next(some.iter(), 0)\n            42\n            &gt;&gt;&gt; null = NULL\n            &gt;&gt;&gt; next(null.iter(), 0)\n            0\n            ```\n\n        Returns:\n            An iterator over the possible value.\n        \"\"\"\n        ...\n\n    @required\n    def async_iter(self) -&gt; AsyncIterator[T]:\n        \"\"\"Returns an asynchronous iterator over the possibly contained value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; some = Some(42)\n            &gt;&gt;&gt; await async_next(some.async_iter(), 0)\n            42\n            &gt;&gt;&gt; null = NULL\n            &gt;&gt;&gt; await async_next(null.async_iter(), 0)\n            0\n            ```\n\n        Returns:\n            An asynchronous iterator over the possible value.\n        \"\"\"\n        ...\n\n    @required\n    def and_then(self, function: Unary[T, Option[U]]) -&gt; Option[U]:\n        \"\"\"Returns the option if it is [`Null`][wraps_core.option.Null],\n        otherwise calls the `function` with the wrapped value and returns the result.\n\n        This function is also known as *bind* in functional programming.\n\n        Example:\n            ```python\n            def inverse(value: float) -&gt; Option[float]:\n                return Some(1.0 / value) if value else NULL\n\n            some = Some(2.0)\n            print(some.and_then(inverse).unwrap())  # 0.5\n\n            zero = Some(0.0)\n            assert zero.and_then(inverse).is_null()\n\n            null = NULL\n            assert null.and_then(inverse).is_null()\n            ```\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    async def and_then_await(self, function: AsyncUnary[T, Option[U]]) -&gt; Option[U]:\n        \"\"\"Returns the option if it is [`Null`][wraps_core.option.Null],\n        otherwise calls the asynchronous `function` with the wrapped value and returns the result.\n\n        Example:\n            ```python\n            async def inverse(value: float) -&gt; Option[float]:\n                return Some(1.0 / value) if value else NULL\n\n            some = Some(2.0)\n            option = await some.and_then_await(inverse)\n\n            print(option.unwrap())  # 0.5\n\n            zero = Some(0.0)\n            option = await zero.and_then_await(inverse)\n\n            assert option.is_null()\n\n            null = NULL\n            option = await null.and_then_await(inverse)\n\n            assert option.is_null()\n            ```\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    def filter(self, predicate: Predicate[T]) -&gt; Option[T]:\n        \"\"\"Returns the option if it is [`Null`][wraps_core.option.Null],\n        otherwise calls the `predicate` with the wrapped value and returns:\n\n        - [`Some(value)`][wraps_core.option.Some] if the contained `value` matches the predicate, and\n        - [`Null`][wraps_core.option.Null] otherwise.\n\n        Example:\n            ```python\n            def is_even(value: int) -&gt; bool:\n                return not value % 2\n\n            null = NULL\n            assert null.filter(is_even).is_null()\n\n            even = Some(2)\n            assert even.filter(is_even).is_some()\n\n            odd = Some(1)\n            assert odd.filter(is_even).is_null()\n            ```\n\n        Arguments:\n            predicate: The predicate to check the contained value against.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    async def filter_await(self, predicate: AsyncPredicate[T]) -&gt; Option[T]:\n        \"\"\"Returns the option if it is [`Null`][wraps_core.option.Null],\n        otherwise calls the asynchronous `predicate` with the wrapped value and returns:\n\n        - [`Some(value)`][wraps_core.option.Some] if the contained `value` matches the predicate, and\n        - [`Null`][wraps_core.option.Null] otherwise.\n\n        Example:\n            ```python\n            async def is_even(value: int) -&gt; bool:\n                return not value % 2\n\n            null = NULL\n            assert (await null.filter_await(is_even)).is_null()\n\n            even = Some(2)\n            assert (await even.filter_await(is_even)).is_some()\n\n            odd = Some(1)\n            assert (await odd.filter_await(is_even)).is_null()\n            ```\n\n        Arguments:\n            predicate: The asynchronous predicate to check the contained value against.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    def or_else(self, default: Nullary[Option[T]]) -&gt; Option[T]:\n        \"\"\"Returns the option if it contains a value, otherwise calls\n        the `default` function and returns the result.\n\n        Example:\n            ```python\n            def default() -&gt; Some[int]:\n                return Some(13)\n\n            some = Some(42)\n            null = NULL\n\n            assert some.or_else(default).is_some()\n            assert null.or_else(default).is_some()\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    async def or_else_await(self, default: AsyncNullary[Option[T]]) -&gt; Option[T]:\n        \"\"\"Returns the option if it contains a value, otherwise calls\n        the asynchronous `default` function and returns the result.\n\n        Example:\n            ```python\n            async def default() -&gt; Some[int]:\n                return Some(13)\n\n            some = Some(42)\n            null = NULL\n\n            assert (await some.or_else_await(default)).is_some()\n            assert (await null.or_else_await(default)).is_some()\n            ```\n\n        Arguments:\n            default: The asynchronous default function to use.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    def xor(self, option: Option[T]) -&gt; Option[T]:\n        \"\"\"Returns [`Some[T]`][wraps_core.option.Some] if exactly one of `self` and `option`\n        is [`Some[T]`][wraps_core.option.Option], otherwise returns [`Null`][wraps_core.option.Null].\n\n        Example:\n            ```python\n            some = Some(69)\n            other = Some(7)\n\n            null = NULL\n\n            assert some.xor(other) == null\n            assert null.xor(other) == other\n            assert some.xor(null) == some\n            assert null.xor(null) == null\n            ```\n\n        Arguments:\n            option: The option to *xor* `self` with.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    def zip(self, option: Option[U]) -&gt; Option[Tuple[T, U]]:\n        \"\"\"Zips `self` with an `option`.\n\n        If `self` is [`Some(s)`][wraps_core.option.Some] and `option` is [`Some(o)`][wraps_core.option.Some],\n        this method returns [`Some((s, o))`][wraps_core.option.Some]. Otherwise,\n        [`Null`][wraps_core.option.Null] is returned.\n\n        Example:\n            ```python\n            x = 0.7\n            y = 1.3\n\n            some_x = Some(x)\n            some_y = Some(y)\n\n            some_tuple = Some((x, y))\n\n            assert some_x.zip(some_y) == some_point\n\n            null = NULL\n\n            assert some_y.zip(null) == null\n            ```\n\n        Arguments:\n            option: The option to *zip* `self` with.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    def zip_with(self, option: Option[U], function: Binary[T, U, V]) -&gt; Option[V]:\n        \"\"\"Zips `self` with an `option` using `function`.\n\n        If `self` is [`Some(s)`][wraps_core.option.Some] and `option` is [`Some(o)`][wraps_core.option.Some],\n        this method returns [`Some(function(s, o))`][wraps_core.option.Some]. Otherwise,\n        [`Null`][wraps_core.option.Null] is returned.\n\n        Example:\n            ```python\n            @frozen()\n            class Point:\n                x: float\n                y: float\n\n            x = 1.3\n            y = 4.2\n\n            some_x = Some(x)\n            some_y = Some(y)\n\n            some_point = Some(Point(x, y))\n\n            assert some_x.zip_with(some_y, Point) == some_point\n\n            null = NULL\n\n            assert some_x.zip_with(null, Point) == null\n            ```\n\n        Arguments:\n            option: The option to *zip* `self` with.\n            function: The function to use for zipping.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    async def zip_with_await(self, option: Option[U], function: AsyncBinary[T, U, V]) -&gt; Option[V]:\n        \"\"\"Zips `self` with an `option` using asynchronous `function`.\n\n        If `self` is [`Some(s)`][wraps_core.option.Some] and `option` is [`Some(o)`][wraps_core.option.Some],\n        this method returns [`Some(await function(s, o))`][wraps_core.option.Some]. Otherwise,\n        [`Null`][wraps_core.option.Null] is returned.\n\n        Example:\n            ```python\n            @frozen()\n            class Point:\n                x: float\n                y: float\n\n            async def point(x: float, y: float) -&gt; Point:\n                return Point(x, y)\n\n            x = 1.3\n            y = 4.2\n\n            some_x = Some(x)\n            some_y = Some(y)\n\n            some_point = Some(Point(x, y))\n\n            assert await some_x.zip_with(some_y, point) == some_point\n\n            null = NULL\n\n            assert await some_x.zip_with(null, point) == null\n            ```\n\n        Arguments:\n            option: The option to *zip* `self` with.\n            function: The asynchronous function to use for zipping.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    def unzip(self: OptionProtocol[Tuple[U, V]]) -&gt; Tuple[Option[U], Option[V]]:\n        \"\"\"Unzips an option into two options.\n\n        If `self` is [`Some((u, v))`][wraps_core.option.Some], this method returns\n        ([`Some(u)`][wraps_core.option.Some], [`Some(v)`][wraps_core.option.Some]) tuple.\n        Otherwise, ([`Null`][wraps_core.option.Null], [`Null`][wraps_core.option.Null]) is returned.\n\n        Example:\n            ```python\n            value = 13\n            other = 42\n\n            zipped = Some((value, other))\n\n            assert zipped.unzip() == (Some(value), Some(other))\n\n            null = NULL\n\n            assert null.unzip() == (NULL, NULL)\n\n        Returns:\n            The resulting tuple of two options.\n        \"\"\"\n        ...\n\n    def flatten(self: OptionProtocol[OptionProtocol[U]]) -&gt; Option[U]:\n        \"\"\"Flattens an [`Option[Option[T]]`][wraps_core.option.Option]\n        to [`Option[T]`][wraps_core.option.Option].\n\n        Example:\n            ```python\n            some = Some(42)\n            some_nested = Some(some)\n            assert some_nested.flatten() == some\n\n            null = NULL\n            null_nested = Some(null)\n            assert null_nested.flatten() == null\n\n            assert null.flatten() == null\n            ```\n\n        Returns:\n            The flattened option.\n        \"\"\"\n        return self.and_then(identity)  # type: ignore[arg-type]\n\n    @required\n    def contains(self, value: U) -&gt; bool:\n        \"\"\"Checks if the contained value (if any) is equal to `value`.\n\n        Example:\n            ```python\n            value = 42\n            other = 69\n\n            some = Some(value)\n            assert some.contains(value)\n            assert not some.contains(other)\n\n            null = NULL\n            assert not null.contains(value)\n            ```\n\n        Arguments:\n            value: The value to check against.\n\n        Returns:\n            Whether the contained value is equal to `value`.\n        \"\"\"\n        ...\n\n    @required\n    def early(self) -&gt; T:\n        \"\"\"Functionally similar to the *question-mark* (`?`) operator in Rust.\n\n        Calls to this method are to be combined with\n        [`@early_option`][wraps_core.early.decorators.early_option] decorators to work properly.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.is_some","title":"<code>is_some() -&gt; bool</code>","text":"<p>Checks if the option is <code>Some[T]</code>.</p> Example <pre><code>some = Some(42)\nassert some.is_some()\n\nnull = NULL\nassert not null.is_some()\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the option is <code>Some[T]</code>.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef is_some(self) -&gt; bool:\n    \"\"\"Checks if the option is [`Some[T]`][wraps_core.option.Some].\n\n    Example:\n        ```python\n        some = Some(42)\n        assert some.is_some()\n\n        null = NULL\n        assert not null.is_some()\n        ```\n\n    Returns:\n        Whether the option is [`Some[T]`][wraps_core.option.Some].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.is_some_and","title":"<code>is_some_and(predicate: Predicate[T]) -&gt; bool</code>","text":"<p>Checks if the option is <code>Some[T]</code> and the value inside of it matches the <code>predicate</code>.</p> Example <pre><code>def is_positive(value: int) -&gt; bool:\n    return value &gt; 0\n\nsome = Some(13)\nassert some.is_some_and(is_positive)\n\nzero = Some(0)\nassert not zero.is_some_and(is_positive)\n\nnull = NULL\nassert not null.is_some_and(is_positive)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Predicate[T]</code> <p>The predicate to check the possibly contained value against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the option is <code>Some[T]</code> and the predicate is matched.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef is_some_and(self, predicate: Predicate[T]) -&gt; bool:\n    \"\"\"Checks if the option is [`Some[T]`][wraps_core.option.Some] and the value\n    inside of it matches the `predicate`.\n\n    Example:\n        ```python\n        def is_positive(value: int) -&gt; bool:\n            return value &gt; 0\n\n        some = Some(13)\n        assert some.is_some_and(is_positive)\n\n        zero = Some(0)\n        assert not zero.is_some_and(is_positive)\n\n        null = NULL\n        assert not null.is_some_and(is_positive)\n        ```\n\n    Arguments:\n        predicate: The predicate to check the possibly contained value against.\n\n    Returns:\n        Whether the option is [`Some[T]`][wraps_core.option.Some] and the predicate is matched.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.is_some_and_await","title":"<code>is_some_and_await(predicate: AsyncPredicate[T]) -&gt; bool</code>  <code>async</code>","text":"<p>Checks if the option is <code>Some[T]</code> and the value inside of it matches the asynchronous <code>predicate</code>.</p> Example <pre><code>async def is_negative(value: int) -&gt; bool:\n    return value &lt; 0\n\nsome = Some(-42)\nassert await some.is_some_and_await(is_negative)\n\nzero = Some(0)\nassert not await zero.is_some_and_await(is_negative)\n\nnull = NULL\nassert not await null.is_some_and_await(is_negative)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>AsyncPredicate[T]</code> <p>The asynchronous predicate to check the possibly contained value against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the option is <code>Some[T]</code> and</p> <code>bool</code> <p>the asynchronous predicate is matched.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def is_some_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n    \"\"\"Checks if the option is [`Some[T]`][wraps_core.option.Some] and the value\n    inside of it matches the asynchronous `predicate`.\n\n    Example:\n        ```python\n        async def is_negative(value: int) -&gt; bool:\n            return value &lt; 0\n\n        some = Some(-42)\n        assert await some.is_some_and_await(is_negative)\n\n        zero = Some(0)\n        assert not await zero.is_some_and_await(is_negative)\n\n        null = NULL\n        assert not await null.is_some_and_await(is_negative)\n        ```\n\n    Arguments:\n        predicate: The asynchronous predicate to check the possibly contained value against.\n\n    Returns:\n        Whether the option is [`Some[T]`][wraps_core.option.Some] and\n        the asynchronous predicate is matched.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.is_null","title":"<code>is_null() -&gt; bool</code>","text":"<p>Checks if the option is <code>Null</code>.</p> Example <pre><code>null = NULL\nassert null.is_null()\n\nsome = Some(34)\nassert not some.is_null()\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the option is <code>Null</code>.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef is_null(self) -&gt; bool:\n    \"\"\"Checks if the option is [`Null`][wraps_core.option.Null].\n\n    Example:\n        ```python\n        null = NULL\n        assert null.is_null()\n\n        some = Some(34)\n        assert not some.is_null()\n        ```\n\n    Returns:\n        Whether the option is [`Null`][wraps_core.option.Null].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.expect","title":"<code>expect(message: str) -&gt; T</code>","text":"<p>Returns the contained <code>Some[T]</code> value.</p> Example <pre><code>&gt;&gt;&gt; some = Some(42)\n&gt;&gt;&gt; some.expect(\"panic!\")\n42\n&gt;&gt;&gt; null = NULL\n&gt;&gt;&gt; null.expect(\"panic!\")\nTraceback (most recent call last):\n  ...\nwraps_core.panics.Panic: panic!\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to use in panicking.</p> required <p>Raises:</p> Type Description <code>Panic</code> <p>Panics with the <code>message</code> if the option is <code>Null</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef expect(self, message: str) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; some = Some(42)\n        &gt;&gt;&gt; some.expect(\"panic!\")\n        42\n        &gt;&gt;&gt; null = NULL\n        &gt;&gt;&gt; null.expect(\"panic!\")\n        Traceback (most recent call last):\n          ...\n        wraps_core.panics.Panic: panic!\n        ```\n\n    Arguments:\n        message: The message to use in panicking.\n\n    Raises:\n        Panic: Panics with the `message` if the option is [`Null`][wraps_core.option.Null].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.extract","title":"<code>extract() -&gt; Optional[T]</code>","text":"<p>Returns the contained <code>Some[T]</code> value or <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; some = Some(42)\n&gt;&gt;&gt; some.extract()\n42\n&gt;&gt;&gt; null = NULL\n&gt;&gt;&gt; null.extract()\n&gt;&gt;&gt; # None\n</code></pre> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The contained value or <code>None</code>.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef extract(self) -&gt; Optional[T]:\n    \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value or [`None`][None].\n\n    Example:\n        ```python\n        &gt;&gt;&gt; some = Some(42)\n        &gt;&gt;&gt; some.extract()\n        42\n        &gt;&gt;&gt; null = NULL\n        &gt;&gt;&gt; null.extract()\n        &gt;&gt;&gt; # None\n        ```\n\n    Returns:\n        The contained value or [`None`][None].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.unwrap","title":"<code>unwrap() -&gt; T</code>","text":"<p>Returns the contained <code>Some[T]</code> value.</p> <p>Because this function may panic, its use is generally discouraged.</p> <p>Instead, prefer to use pattern matching and handle the <code>Null</code> case explicitly, or call <code>unwrap_or</code> or <code>unwrap_or_else</code>.</p> Example <pre><code>&gt;&gt;&gt; some = Some(42)\n&gt;&gt;&gt; some.unwrap()\n42\n&gt;&gt;&gt; null = NULL\n&gt;&gt;&gt; null.unwrap()\nTraceback (most recent call last):\n  ...\nwraps_core.panics.Panic: called `unwrap` on null\n</code></pre> <p>Raises:</p> Type Description <code>Panic</code> <p>Panics if the option is <code>Null</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef unwrap(self) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value.\n\n    Because this function may panic, its use is generally discouraged.\n\n    Instead, prefer to use pattern matching and handle the [`Null`][wraps_core.option.Null]\n    case explicitly, or call [`unwrap_or`][wraps_core.option.OptionProtocol.unwrap_or]\n    or [`unwrap_or_else`][wraps_core.option.OptionProtocol.unwrap_or_else].\n\n    Example:\n        ```python\n        &gt;&gt;&gt; some = Some(42)\n        &gt;&gt;&gt; some.unwrap()\n        42\n        &gt;&gt;&gt; null = NULL\n        &gt;&gt;&gt; null.unwrap()\n        Traceback (most recent call last):\n          ...\n        wraps_core.panics.Panic: called `unwrap` on null\n        ```\n\n    Raises:\n        Panic: Panics if the option is [`Null`][wraps_core.option.Null].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.unwrap_or","title":"<code>unwrap_or(default: T) -&gt; T</code>","text":"<p>Returns the contained <code>Some[T]</code> value or the provided <code>default</code>.</p> Example <pre><code>some = Some(13)\nassert some.unwrap_or(0)\n\nnull = NULL\nassert not null.unwrap_or(0)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>T</code> <p>The default value to use.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The contained value or the <code>default</code> one.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef unwrap_or(self, default: T) -&gt; T:  # type: ignore[misc]\n    \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value or the provided `default`.\n\n    Example:\n        ```python\n        some = Some(13)\n        assert some.unwrap_or(0)\n\n        null = NULL\n        assert not null.unwrap_or(0)\n        ```\n\n    Arguments:\n        default: The default value to use.\n\n    Returns:\n        The contained value or the `default` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.unwrap_or_else","title":"<code>unwrap_or_else(default: Nullary[T]) -&gt; T</code>","text":"<p>Returns the contained <code>Some[T]</code> value or computes it from the <code>default</code> function.</p> Example <pre><code>some = Some(13)\nassert some.unwrap_or_else(int)\n\nnull = NULL\nassert not null.unwrap_or_else(int)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[T]</code> <p>The default-computing function to use.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The contained value or the <code>default()</code> one.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef unwrap_or_else(self, default: Nullary[T]) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value or\n    computes it from the `default` function.\n\n    Example:\n        ```python\n        some = Some(13)\n        assert some.unwrap_or_else(int)\n\n        null = NULL\n        assert not null.unwrap_or_else(int)\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n\n    Returns:\n        The contained value or the `default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.unwrap_or_else_await","title":"<code>unwrap_or_else_await(default: AsyncNullary[T]) -&gt; T</code>  <code>async</code>","text":"<p>Returns the contained <code>Some[T]</code> value or computes it from the asynchronous <code>default</code> function.</p> Example <pre><code>async def default() -&gt; int:\n    return 0\n\nsome = Some(42)\nassert await some.unwrap_or_else_await(default)\n\nnull = NULL\nassert not await null.unwrap_or_else_await(default)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[T]</code> <p>The asynchronous default-computing function to use.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The contained value or the <code>await default()</code> one.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value\n    or computes it from the asynchronous `default` function.\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 0\n\n        some = Some(42)\n        assert await some.unwrap_or_else_await(default)\n\n        null = NULL\n        assert not await null.unwrap_or_else_await(default)\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n\n    Returns:\n        The contained value or the `await default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.or_raise","title":"<code>or_raise(error: AnyError) -&gt; T</code>","text":"<p>Returns the contained <code>Some[T]</code> value or raises the <code>error</code> provided.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AnyError</code> <p>The error to raise if the option is <code>Null</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error provided, if the option is <code>Null</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef or_raise(self, error: AnyError) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value\n    or raises the `error` provided.\n\n    Arguments:\n        error: The error to raise if the option is [`Null`][wraps_core.option.Null].\n\n    Raises:\n        AnyError: The error provided, if the option is [`Null`][wraps_core.option.Null].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.or_raise_with","title":"<code>or_raise_with(error: Nullary[AnyError]) -&gt; T</code>","text":"<p>Returns the contained <code>Some[T]</code> value or raises the error computed from <code>error</code>.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Nullary[AnyError]</code> <p>The error to raise if the option is <code>Null</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error computed, if the option is <code>Null</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value\n    or raises the error computed from `error`.\n\n    Arguments:\n        error: The error to raise if the option is [`Null`][wraps_core.option.Null].\n\n    Raises:\n        AnyError: The error computed, if the option is [`Null`][wraps_core.option.Null].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.or_raise_with_await","title":"<code>or_raise_with_await(error: AsyncNullary[AnyError]) -&gt; T</code>  <code>async</code>","text":"<p>Returns the contained <code>Some[T]</code> value or raises the error computed asynchronously from <code>error</code>.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AsyncNullary[AnyError]</code> <p>The error to raise if the option is <code>Null</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error computed, if the option is <code>Null</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps_core.option.Some] value\n    or raises the error computed asynchronously from `error`.\n\n    Arguments:\n        error: The error to raise if the option is [`Null`][wraps_core.option.Null].\n\n    Raises:\n        AnyError: The error computed, if the option is [`Null`][wraps_core.option.Null].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.inspect","title":"<code>inspect(function: Inspect[T]) -&gt; Option[T]</code>","text":"<p>Inspects a possibly contained <code>Option[T]</code> value.</p> Example <pre><code>some = Some(\"Hello, world!\")\n\nsame = some.inspect(print)  # Hello, world!\n\nassert some == same\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Inspect[T]</code> <p>The inspecting function.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The inspected option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef inspect(self, function: Inspect[T]) -&gt; Option[T]:\n    \"\"\"Inspects a possibly contained [`Option[T]`][wraps_core.option.Option] value.\n\n    Example:\n        ```python\n        some = Some(\"Hello, world!\")\n\n        same = some.inspect(print)  # Hello, world!\n\n        assert some == same\n        ```\n\n    Arguments:\n        function: The inspecting function.\n\n    Returns:\n        The inspected option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.inspect_await","title":"<code>inspect_await(function: AsyncInspect[T]) -&gt; Option[T]</code>  <code>async</code>","text":"<p>Inspects a possibly contained <code>Option[T]</code> value.</p> Example <pre><code>async def function(value: str) -&gt; None:\n    print(value)\n\nsome = Some(\"Hello, world!\")\n\nsame = await some.inspect(function)  # Hello, world!\n\nassert some == same\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncInspect[T]</code> <p>The asynchronous inspecting function.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The inspected option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def inspect_await(self, function: AsyncInspect[T]) -&gt; Option[T]:\n    \"\"\"Inspects a possibly contained [`Option[T]`][wraps_core.option.Option] value.\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; None:\n            print(value)\n\n        some = Some(\"Hello, world!\")\n\n        same = await some.inspect(function)  # Hello, world!\n\n        assert some == same\n        ```\n\n    Arguments:\n        function: The asynchronous inspecting function.\n\n    Returns:\n        The inspected option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.map","title":"<code>map(function: Unary[T, U]) -&gt; Option[U]</code>","text":"<p>Maps an <code>Option[T]</code> to an <code>Option[U]</code> by applying the <code>function</code> to the contained value.</p> Example <pre><code>some = Some(\"Hello, world!\")\n\nprint(some.map(len).unwrap())  # 13\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Option[U]</code> <p>The mapped option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef map(self, function: Unary[T, U]) -&gt; Option[U]:\n    \"\"\"Maps an [`Option[T]`][wraps_core.option.Option] to an [`Option[U]`][wraps_core.option.Option]\n    by applying the `function` to the contained value.\n\n    Example:\n        ```python\n        some = Some(\"Hello, world!\")\n\n        print(some.map(len).unwrap())  # 13\n        ```\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The mapped option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.map_or","title":"<code>map_or(default: U, function: Unary[T, U]) -&gt; U</code>","text":"<p>Returns the <code>default</code> value (if none), or applies the <code>function</code> to the contained value (if any).</p> Example <pre><code>some = Some(\"nekit\")\n\nprint(some.map_or(42, len))  # 5\n\nnull = NULL\n\nprint(null.map_or(42, len))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>U</code> <p>The default value to use.</p> required <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting value or the <code>default</code> one.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n    \"\"\"Returns the `default` value (if none), or applies the `function`\n    to the contained value (if any).\n\n    Example:\n        ```python\n        some = Some(\"nekit\")\n\n        print(some.map_or(42, len))  # 5\n\n        null = NULL\n\n        print(null.map_or(42, len))  # 42\n        ```\n\n    Arguments:\n        default: The default value to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting value or the `default` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.map_or_else","title":"<code>map_or_else(default: Nullary[U], function: Unary[T, U]) -&gt; U</code>","text":"<p>Computes the default value from the <code>default</code> function (if none), or applies the <code>function</code> to the contained value (if any).</p> Example <pre><code>def default() -&gt; int:\n    return 42\n\nsome = Some(\"Hello, world!\")\n\nprint(some.map_or_else(default, len))  # 13\n\nnull = NULL\n\nprint(null.map_or_else(default, len))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[U]</code> <p>The default-computing function to use.</p> required <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting value or the <code>default()</code> one.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n    \"\"\"Computes the default value from the `default` function (if none),\n    or applies the `function` to the contained value (if any).\n\n    Example:\n        ```python\n        def default() -&gt; int:\n            return 42\n\n        some = Some(\"Hello, world!\")\n\n        print(some.map_or_else(default, len))  # 13\n\n        null = NULL\n\n        print(null.map_or_else(default, len))  # 42\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting value or the `default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.map_or_else_await","title":"<code>map_or_else_await(default: AsyncNullary[U], function: Unary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Computes the default value from the asynchronous <code>default</code> function (if none), or applies the <code>function</code> to the contained value (if any).</p> Example <pre><code>async def default() -&gt; int:\n    return 42\n\nsome = Some(\"Hello, world!\")\n\nprint(await some.map_or_else_await(default, len))  # 13\n\nnull = NULL\n\nprint(await null.map_or_else_await(default, len))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[U]</code> <p>The asynchronous default-computing function to use.</p> required <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting value or the <code>await default()</code> one.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n    \"\"\"Computes the default value from the asynchronous `default` function (if none),\n    or applies the `function` to the contained value (if any).\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 42\n\n        some = Some(\"Hello, world!\")\n\n        print(await some.map_or_else_await(default, len))  # 13\n\n        null = NULL\n\n        print(await null.map_or_else_await(default, len))  # 42\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting value or the `await default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.map_await","title":"<code>map_await(function: AsyncUnary[T, U]) -&gt; Option[U]</code>  <code>async</code>","text":"<p>Maps an <code>Option[T]</code> to an <code>Option[U]</code> by applying the asynchronous <code>function</code> to the contained value.</p> Example <pre><code>async def function(value: str) -&gt; int:\n    return len(value)\n\nsome = Some(\"Hello, world!\")\n\nmapped = await some.map_await(function)\n\nprint(some.unwrap())  # 13\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Option[U]</code> <p>The mapped option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def map_await(self, function: AsyncUnary[T, U]) -&gt; Option[U]:\n    \"\"\"Maps an [`Option[T]`][wraps_core.option.Option] to an [`Option[U]`][wraps_core.option.Option]\n    by applying the asynchronous `function` to the contained value.\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        some = Some(\"Hello, world!\")\n\n        mapped = await some.map_await(function)\n\n        print(some.unwrap())  # 13\n        ```\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The mapped option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.map_await_or","title":"<code>map_await_or(default: U, function: AsyncUnary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Returns the <code>default</code> value (if none), or applies the asynchronous <code>function</code> to the contained value (if any).</p> Example <pre><code>async def function(value: str) -&gt; int:\n    return len(value)\n\nsome = Some(\"nekit\")\n\nprint(await some.map_await_or(42, function))  # 5\n\nnull = NULL\n\nprint(await null.map_await_or(42, function))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>U</code> <p>The default value to use.</p> required <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting value or the <code>default</code> one.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n    \"\"\"Returns the `default` value (if none), or applies the asynchronous `function`\n    to the contained value (if any).\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        some = Some(\"nekit\")\n\n        print(await some.map_await_or(42, function))  # 5\n\n        null = NULL\n\n        print(await null.map_await_or(42, function))  # 42\n        ```\n\n    Arguments:\n        default: The default value to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting value or the `default` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.map_await_or_else","title":"<code>map_await_or_else(default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Computes the default value from the <code>default</code> function (if none), or applies the asynchronous <code>function</code> to the contained value (if any).</p> Example <pre><code>async def function(value: str) -&gt; int:\n    return len(value)\n\ndef default() -&gt; int:\n    return 0\n\nsome = Some(\"Hello, world!\")\n\nprint(await some.map_await_or_else(default, function))  # 13\n\nnull = NULL\n\nprint(await null.map_await_or_else(default, function))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[U]</code> <p>The default-computing function to use.</p> required <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting value or the <code>default()</code> one.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n    \"\"\"Computes the default value from the `default` function (if none),\n    or applies the asynchronous `function` to the contained value (if any).\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        def default() -&gt; int:\n            return 0\n\n        some = Some(\"Hello, world!\")\n\n        print(await some.map_await_or_else(default, function))  # 13\n\n        null = NULL\n\n        print(await null.map_await_or_else(default, function))  # 0\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting value or the `default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.map_await_or_else_await","title":"<code>map_await_or_else_await(default: AsyncNullary[U], function: AsyncUnary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Computes the default value (if none), or applies the asynchronous <code>function</code> to the contained value (if any).</p> Example <pre><code>async def default() -&gt; int:\n    return 42\n\nasync def function(value: str) -&gt; int:\n    return len(value)\n\nsome = Some(\"Hello, world!\")\n\nprint(await some.map_await_or_else_await(default, function))  # 13\n\nnull = NULL\n\nprint(await null.map_await_or_else_await(default, function))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[U]</code> <p>The asynchronous default function to use.</p> required <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting value or the <code>await default()</code> one.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def map_await_or_else_await(\n    self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n) -&gt; U:\n    \"\"\"Computes the default value (if none), or applies the asynchronous `function`\n    to the contained value (if any).\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 42\n\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        some = Some(\"Hello, world!\")\n\n        print(await some.map_await_or_else_await(default, function))  # 13\n\n        null = NULL\n\n        print(await null.map_await_or_else_await(default, function))  # 42\n        ```\n\n    Arguments:\n        default: The asynchronous default function to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting value or the `await default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.ok_or","title":"<code>ok_or(error: E) -&gt; Result[T, E]</code>","text":"<p>Transforms an <code>Option[T]</code> into a <code>Result[T, E]</code>, mapping <code>Some(value)</code> to <code>Ok(value)</code> and <code>Null</code> to <code>Error(error)</code>.</p> Example <pre><code>error = Error(13)\n\nsome = Some(42)\nassert some.ok_or(error).is_ok()\n\nnull = NULL\nassert null.ok_or(error).is_error()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>E</code> <p>The error to use.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The transformed result.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef ok_or(self, error: E) -&gt; Result[T, E]:\n    \"\"\"Transforms an [`Option[T]`][wraps_core.option.Option]\n    into a [`Result[T, E]`][wraps_core.result.Result], mapping [`Some(value)`][wraps_core.option.Some]\n    to [`Ok(value)`][wraps_core.result.Ok] and [`Null`][wraps_core.option.Null]\n    to [`Error(error)`][wraps_core.result.Error].\n\n    Example:\n        ```python\n        error = Error(13)\n\n        some = Some(42)\n        assert some.ok_or(error).is_ok()\n\n        null = NULL\n        assert null.ok_or(error).is_error()\n        ```\n\n    Arguments:\n        error: The error to use.\n\n    Returns:\n        The transformed result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.ok_or_else","title":"<code>ok_or_else(error: Nullary[E]) -&gt; Result[T, E]</code>","text":"<p>Transforms an <code>Option[T]</code> into a <code>Result[T, E]</code>, mapping <code>Some(value)</code> to <code>Ok(value)</code> and <code>Null</code> to <code>Error(error())</code>.</p> Example <pre><code>def error() -&gt; Error[int]:\n    return Error(0)\n\nsome = Some(7)\nassert some.ok_or_else(error).is_ok()\n\nnull = NULL\nassert null.ok_or_else(error).is_error()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Nullary[E]</code> <p>The error-computing function to use.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The transformed result.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef ok_or_else(self, error: Nullary[E]) -&gt; Result[T, E]:\n    \"\"\"Transforms an [`Option[T]`][wraps_core.option.Option]\n    into a [`Result[T, E]`][wraps_core.result.Result], mapping [`Some(value)`][wraps_core.option.Some]\n    to [`Ok(value)`][wraps_core.result.Ok] and [`Null`][wraps_core.option.Null]\n    to [`Error(error())`][wraps_core.result.Error].\n\n    Example:\n        ```python\n        def error() -&gt; Error[int]:\n            return Error(0)\n\n        some = Some(7)\n        assert some.ok_or_else(error).is_ok()\n\n        null = NULL\n        assert null.ok_or_else(error).is_error()\n        ```\n\n    Arguments:\n        error: The error-computing function to use.\n\n    Returns:\n        The transformed result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.ok_or_else_await","title":"<code>ok_or_else_await(error: AsyncNullary[E]) -&gt; Result[T, E]</code>  <code>async</code>","text":"<p>Transforms an <code>Option[T]</code> into a <code>Result[T, E]</code>, mapping <code>Some(value)</code> to <code>Ok(value)</code> and <code>Null</code> to <code>Error(await error())</code>.</p> Example <pre><code>async def error() -&gt; Error[int]:\n    return Error(0)\n\nsome = Some(7)\nresult = await some.ok_or_else_await(error)\n\nassert result.is_ok()\n\nnull = NULL\nresult = await null.ok_or_else_await(error)\n\nassert result.is_error()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AsyncNullary[E]</code> <p>The error-computing function to use.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The transformed result.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def ok_or_else_await(self, error: AsyncNullary[E]) -&gt; Result[T, E]:\n    \"\"\"Transforms an [`Option[T]`][wraps_core.option.Option]\n    into a [`Result[T, E]`][wraps_core.result.Result], mapping [`Some(value)`][wraps_core.option.Some]\n    to [`Ok(value)`][wraps_core.result.Ok] and [`Null`][wraps_core.option.Null]\n    to [`Error(await error())`][wraps_core.result.Error].\n\n    Example:\n        ```python\n        async def error() -&gt; Error[int]:\n            return Error(0)\n\n        some = Some(7)\n        result = await some.ok_or_else_await(error)\n\n        assert result.is_ok()\n\n        null = NULL\n        result = await null.ok_or_else_await(error)\n\n        assert result.is_error()\n        ```\n\n    Arguments:\n        error: The error-computing function to use.\n\n    Returns:\n        The transformed result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.iter","title":"<code>iter() -&gt; Iterator[T]</code>","text":"<p>Returns an iterator over the possibly contained value.</p> Example <pre><code>&gt;&gt;&gt; some = Some(42)\n&gt;&gt;&gt; next(some.iter(), 0)\n42\n&gt;&gt;&gt; null = NULL\n&gt;&gt;&gt; next(null.iter(), 0)\n0\n</code></pre> <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>An iterator over the possible value.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef iter(self) -&gt; Iterator[T]:\n    \"\"\"Returns an iterator over the possibly contained value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; some = Some(42)\n        &gt;&gt;&gt; next(some.iter(), 0)\n        42\n        &gt;&gt;&gt; null = NULL\n        &gt;&gt;&gt; next(null.iter(), 0)\n        0\n        ```\n\n    Returns:\n        An iterator over the possible value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.async_iter","title":"<code>async_iter() -&gt; AsyncIterator[T]</code>","text":"<p>Returns an asynchronous iterator over the possibly contained value.</p> Example <pre><code>&gt;&gt;&gt; some = Some(42)\n&gt;&gt;&gt; await async_next(some.async_iter(), 0)\n42\n&gt;&gt;&gt; null = NULL\n&gt;&gt;&gt; await async_next(null.async_iter(), 0)\n0\n</code></pre> <p>Returns:</p> Type Description <code>AsyncIterator[T]</code> <p>An asynchronous iterator over the possible value.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef async_iter(self) -&gt; AsyncIterator[T]:\n    \"\"\"Returns an asynchronous iterator over the possibly contained value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; some = Some(42)\n        &gt;&gt;&gt; await async_next(some.async_iter(), 0)\n        42\n        &gt;&gt;&gt; null = NULL\n        &gt;&gt;&gt; await async_next(null.async_iter(), 0)\n        0\n        ```\n\n    Returns:\n        An asynchronous iterator over the possible value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.and_then","title":"<code>and_then(function: Unary[T, Option[U]]) -&gt; Option[U]</code>","text":"<p>Returns the option if it is <code>Null</code>, otherwise calls the <code>function</code> with the wrapped value and returns the result.</p> <p>This function is also known as bind in functional programming.</p> Example <pre><code>def inverse(value: float) -&gt; Option[float]:\n    return Some(1.0 / value) if value else NULL\n\nsome = Some(2.0)\nprint(some.and_then(inverse).unwrap())  # 0.5\n\nzero = Some(0.0)\nassert zero.and_then(inverse).is_null()\n\nnull = NULL\nassert null.and_then(inverse).is_null()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[T, Option[U]]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Option[U]</code> <p>The resulting option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef and_then(self, function: Unary[T, Option[U]]) -&gt; Option[U]:\n    \"\"\"Returns the option if it is [`Null`][wraps_core.option.Null],\n    otherwise calls the `function` with the wrapped value and returns the result.\n\n    This function is also known as *bind* in functional programming.\n\n    Example:\n        ```python\n        def inverse(value: float) -&gt; Option[float]:\n            return Some(1.0 / value) if value else NULL\n\n        some = Some(2.0)\n        print(some.and_then(inverse).unwrap())  # 0.5\n\n        zero = Some(0.0)\n        assert zero.and_then(inverse).is_null()\n\n        null = NULL\n        assert null.and_then(inverse).is_null()\n        ```\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.and_then_await","title":"<code>and_then_await(function: AsyncUnary[T, Option[U]]) -&gt; Option[U]</code>  <code>async</code>","text":"<p>Returns the option if it is <code>Null</code>, otherwise calls the asynchronous <code>function</code> with the wrapped value and returns the result.</p> Example <pre><code>async def inverse(value: float) -&gt; Option[float]:\n    return Some(1.0 / value) if value else NULL\n\nsome = Some(2.0)\noption = await some.and_then_await(inverse)\n\nprint(option.unwrap())  # 0.5\n\nzero = Some(0.0)\noption = await zero.and_then_await(inverse)\n\nassert option.is_null()\n\nnull = NULL\noption = await null.and_then_await(inverse)\n\nassert option.is_null()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[T, Option[U]]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Option[U]</code> <p>The resulting option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def and_then_await(self, function: AsyncUnary[T, Option[U]]) -&gt; Option[U]:\n    \"\"\"Returns the option if it is [`Null`][wraps_core.option.Null],\n    otherwise calls the asynchronous `function` with the wrapped value and returns the result.\n\n    Example:\n        ```python\n        async def inverse(value: float) -&gt; Option[float]:\n            return Some(1.0 / value) if value else NULL\n\n        some = Some(2.0)\n        option = await some.and_then_await(inverse)\n\n        print(option.unwrap())  # 0.5\n\n        zero = Some(0.0)\n        option = await zero.and_then_await(inverse)\n\n        assert option.is_null()\n\n        null = NULL\n        option = await null.and_then_await(inverse)\n\n        assert option.is_null()\n        ```\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.filter","title":"<code>filter(predicate: Predicate[T]) -&gt; Option[T]</code>","text":"<p>Returns the option if it is <code>Null</code>, otherwise calls the <code>predicate</code> with the wrapped value and returns:</p> <ul> <li><code>Some(value)</code> if the contained <code>value</code> matches the predicate, and</li> <li><code>Null</code> otherwise.</li> </ul> Example <pre><code>def is_even(value: int) -&gt; bool:\n    return not value % 2\n\nnull = NULL\nassert null.filter(is_even).is_null()\n\neven = Some(2)\nassert even.filter(is_even).is_some()\n\nodd = Some(1)\nassert odd.filter(is_even).is_null()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Predicate[T]</code> <p>The predicate to check the contained value against.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The resulting option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef filter(self, predicate: Predicate[T]) -&gt; Option[T]:\n    \"\"\"Returns the option if it is [`Null`][wraps_core.option.Null],\n    otherwise calls the `predicate` with the wrapped value and returns:\n\n    - [`Some(value)`][wraps_core.option.Some] if the contained `value` matches the predicate, and\n    - [`Null`][wraps_core.option.Null] otherwise.\n\n    Example:\n        ```python\n        def is_even(value: int) -&gt; bool:\n            return not value % 2\n\n        null = NULL\n        assert null.filter(is_even).is_null()\n\n        even = Some(2)\n        assert even.filter(is_even).is_some()\n\n        odd = Some(1)\n        assert odd.filter(is_even).is_null()\n        ```\n\n    Arguments:\n        predicate: The predicate to check the contained value against.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.filter_await","title":"<code>filter_await(predicate: AsyncPredicate[T]) -&gt; Option[T]</code>  <code>async</code>","text":"<p>Returns the option if it is <code>Null</code>, otherwise calls the asynchronous <code>predicate</code> with the wrapped value and returns:</p> <ul> <li><code>Some(value)</code> if the contained <code>value</code> matches the predicate, and</li> <li><code>Null</code> otherwise.</li> </ul> Example <pre><code>async def is_even(value: int) -&gt; bool:\n    return not value % 2\n\nnull = NULL\nassert (await null.filter_await(is_even)).is_null()\n\neven = Some(2)\nassert (await even.filter_await(is_even)).is_some()\n\nodd = Some(1)\nassert (await odd.filter_await(is_even)).is_null()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>AsyncPredicate[T]</code> <p>The asynchronous predicate to check the contained value against.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The resulting option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def filter_await(self, predicate: AsyncPredicate[T]) -&gt; Option[T]:\n    \"\"\"Returns the option if it is [`Null`][wraps_core.option.Null],\n    otherwise calls the asynchronous `predicate` with the wrapped value and returns:\n\n    - [`Some(value)`][wraps_core.option.Some] if the contained `value` matches the predicate, and\n    - [`Null`][wraps_core.option.Null] otherwise.\n\n    Example:\n        ```python\n        async def is_even(value: int) -&gt; bool:\n            return not value % 2\n\n        null = NULL\n        assert (await null.filter_await(is_even)).is_null()\n\n        even = Some(2)\n        assert (await even.filter_await(is_even)).is_some()\n\n        odd = Some(1)\n        assert (await odd.filter_await(is_even)).is_null()\n        ```\n\n    Arguments:\n        predicate: The asynchronous predicate to check the contained value against.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.or_else","title":"<code>or_else(default: Nullary[Option[T]]) -&gt; Option[T]</code>","text":"<p>Returns the option if it contains a value, otherwise calls the <code>default</code> function and returns the result.</p> Example <pre><code>def default() -&gt; Some[int]:\n    return Some(13)\n\nsome = Some(42)\nnull = NULL\n\nassert some.or_else(default).is_some()\nassert null.or_else(default).is_some()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[Option[T]]</code> <p>The default-computing function to use.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The resulting option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef or_else(self, default: Nullary[Option[T]]) -&gt; Option[T]:\n    \"\"\"Returns the option if it contains a value, otherwise calls\n    the `default` function and returns the result.\n\n    Example:\n        ```python\n        def default() -&gt; Some[int]:\n            return Some(13)\n\n        some = Some(42)\n        null = NULL\n\n        assert some.or_else(default).is_some()\n        assert null.or_else(default).is_some()\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.or_else_await","title":"<code>or_else_await(default: AsyncNullary[Option[T]]) -&gt; Option[T]</code>  <code>async</code>","text":"<p>Returns the option if it contains a value, otherwise calls the asynchronous <code>default</code> function and returns the result.</p> Example <pre><code>async def default() -&gt; Some[int]:\n    return Some(13)\n\nsome = Some(42)\nnull = NULL\n\nassert (await some.or_else_await(default)).is_some()\nassert (await null.or_else_await(default)).is_some()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[Option[T]]</code> <p>The asynchronous default function to use.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The resulting option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def or_else_await(self, default: AsyncNullary[Option[T]]) -&gt; Option[T]:\n    \"\"\"Returns the option if it contains a value, otherwise calls\n    the asynchronous `default` function and returns the result.\n\n    Example:\n        ```python\n        async def default() -&gt; Some[int]:\n            return Some(13)\n\n        some = Some(42)\n        null = NULL\n\n        assert (await some.or_else_await(default)).is_some()\n        assert (await null.or_else_await(default)).is_some()\n        ```\n\n    Arguments:\n        default: The asynchronous default function to use.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.xor","title":"<code>xor(option: Option[T]) -&gt; Option[T]</code>","text":"<p>Returns <code>Some[T]</code> if exactly one of <code>self</code> and <code>option</code> is <code>Some[T]</code>, otherwise returns <code>Null</code>.</p> Example <pre><code>some = Some(69)\nother = Some(7)\n\nnull = NULL\n\nassert some.xor(other) == null\nassert null.xor(other) == other\nassert some.xor(null) == some\nassert null.xor(null) == null\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>Option[T]</code> <p>The option to xor <code>self</code> with.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The resulting option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef xor(self, option: Option[T]) -&gt; Option[T]:\n    \"\"\"Returns [`Some[T]`][wraps_core.option.Some] if exactly one of `self` and `option`\n    is [`Some[T]`][wraps_core.option.Option], otherwise returns [`Null`][wraps_core.option.Null].\n\n    Example:\n        ```python\n        some = Some(69)\n        other = Some(7)\n\n        null = NULL\n\n        assert some.xor(other) == null\n        assert null.xor(other) == other\n        assert some.xor(null) == some\n        assert null.xor(null) == null\n        ```\n\n    Arguments:\n        option: The option to *xor* `self` with.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.zip","title":"<code>zip(option: Option[U]) -&gt; Option[Tuple[T, U]]</code>","text":"<p>Zips <code>self</code> with an <code>option</code>.</p> <p>If <code>self</code> is <code>Some(s)</code> and <code>option</code> is <code>Some(o)</code>, this method returns <code>Some((s, o))</code>. Otherwise, <code>Null</code> is returned.</p> Example <pre><code>x = 0.7\ny = 1.3\n\nsome_x = Some(x)\nsome_y = Some(y)\n\nsome_tuple = Some((x, y))\n\nassert some_x.zip(some_y) == some_point\n\nnull = NULL\n\nassert some_y.zip(null) == null\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>Option[U]</code> <p>The option to zip <code>self</code> with.</p> required <p>Returns:</p> Type Description <code>Option[Tuple[T, U]]</code> <p>The resulting option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef zip(self, option: Option[U]) -&gt; Option[Tuple[T, U]]:\n    \"\"\"Zips `self` with an `option`.\n\n    If `self` is [`Some(s)`][wraps_core.option.Some] and `option` is [`Some(o)`][wraps_core.option.Some],\n    this method returns [`Some((s, o))`][wraps_core.option.Some]. Otherwise,\n    [`Null`][wraps_core.option.Null] is returned.\n\n    Example:\n        ```python\n        x = 0.7\n        y = 1.3\n\n        some_x = Some(x)\n        some_y = Some(y)\n\n        some_tuple = Some((x, y))\n\n        assert some_x.zip(some_y) == some_point\n\n        null = NULL\n\n        assert some_y.zip(null) == null\n        ```\n\n    Arguments:\n        option: The option to *zip* `self` with.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.zip_with","title":"<code>zip_with(option: Option[U], function: Binary[T, U, V]) -&gt; Option[V]</code>","text":"<p>Zips <code>self</code> with an <code>option</code> using <code>function</code>.</p> <p>If <code>self</code> is <code>Some(s)</code> and <code>option</code> is <code>Some(o)</code>, this method returns <code>Some(function(s, o))</code>. Otherwise, <code>Null</code> is returned.</p> Example <pre><code>@frozen()\nclass Point:\n    x: float\n    y: float\n\nx = 1.3\ny = 4.2\n\nsome_x = Some(x)\nsome_y = Some(y)\n\nsome_point = Some(Point(x, y))\n\nassert some_x.zip_with(some_y, Point) == some_point\n\nnull = NULL\n\nassert some_x.zip_with(null, Point) == null\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>Option[U]</code> <p>The option to zip <code>self</code> with.</p> required <code>function</code> <code>Binary[T, U, V]</code> <p>The function to use for zipping.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>The resulting option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef zip_with(self, option: Option[U], function: Binary[T, U, V]) -&gt; Option[V]:\n    \"\"\"Zips `self` with an `option` using `function`.\n\n    If `self` is [`Some(s)`][wraps_core.option.Some] and `option` is [`Some(o)`][wraps_core.option.Some],\n    this method returns [`Some(function(s, o))`][wraps_core.option.Some]. Otherwise,\n    [`Null`][wraps_core.option.Null] is returned.\n\n    Example:\n        ```python\n        @frozen()\n        class Point:\n            x: float\n            y: float\n\n        x = 1.3\n        y = 4.2\n\n        some_x = Some(x)\n        some_y = Some(y)\n\n        some_point = Some(Point(x, y))\n\n        assert some_x.zip_with(some_y, Point) == some_point\n\n        null = NULL\n\n        assert some_x.zip_with(null, Point) == null\n        ```\n\n    Arguments:\n        option: The option to *zip* `self` with.\n        function: The function to use for zipping.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.zip_with_await","title":"<code>zip_with_await(option: Option[U], function: AsyncBinary[T, U, V]) -&gt; Option[V]</code>  <code>async</code>","text":"<p>Zips <code>self</code> with an <code>option</code> using asynchronous <code>function</code>.</p> <p>If <code>self</code> is <code>Some(s)</code> and <code>option</code> is <code>Some(o)</code>, this method returns <code>Some(await function(s, o))</code>. Otherwise, <code>Null</code> is returned.</p> Example <pre><code>@frozen()\nclass Point:\n    x: float\n    y: float\n\nasync def point(x: float, y: float) -&gt; Point:\n    return Point(x, y)\n\nx = 1.3\ny = 4.2\n\nsome_x = Some(x)\nsome_y = Some(y)\n\nsome_point = Some(Point(x, y))\n\nassert await some_x.zip_with(some_y, point) == some_point\n\nnull = NULL\n\nassert await some_x.zip_with(null, point) == null\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>Option[U]</code> <p>The option to zip <code>self</code> with.</p> required <code>function</code> <code>AsyncBinary[T, U, V]</code> <p>The asynchronous function to use for zipping.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>The resulting option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\nasync def zip_with_await(self, option: Option[U], function: AsyncBinary[T, U, V]) -&gt; Option[V]:\n    \"\"\"Zips `self` with an `option` using asynchronous `function`.\n\n    If `self` is [`Some(s)`][wraps_core.option.Some] and `option` is [`Some(o)`][wraps_core.option.Some],\n    this method returns [`Some(await function(s, o))`][wraps_core.option.Some]. Otherwise,\n    [`Null`][wraps_core.option.Null] is returned.\n\n    Example:\n        ```python\n        @frozen()\n        class Point:\n            x: float\n            y: float\n\n        async def point(x: float, y: float) -&gt; Point:\n            return Point(x, y)\n\n        x = 1.3\n        y = 4.2\n\n        some_x = Some(x)\n        some_y = Some(y)\n\n        some_point = Some(Point(x, y))\n\n        assert await some_x.zip_with(some_y, point) == some_point\n\n        null = NULL\n\n        assert await some_x.zip_with(null, point) == null\n        ```\n\n    Arguments:\n        option: The option to *zip* `self` with.\n        function: The asynchronous function to use for zipping.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.unzip","title":"<code>unzip() -&gt; Tuple[Option[U], Option[V]]</code>","text":"<p>Unzips an option into two options.</p> <p>If <code>self</code> is <code>Some((u, v))</code>, this method returns (<code>Some(u)</code>, <code>Some(v)</code>) tuple. Otherwise, (<code>Null</code>, <code>Null</code>) is returned.</p> Example <p>```python value = 13 other = 42</p> <p>zipped = Some((value, other))</p> <p>assert zipped.unzip() == (Some(value), Some(other))</p> <p>null = NULL</p> <p>assert null.unzip() == (NULL, NULL)</p> <p>Returns:</p> Type Description <code>Tuple[Option[U], Option[V]]</code> <p>The resulting tuple of two options.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef unzip(self: OptionProtocol[Tuple[U, V]]) -&gt; Tuple[Option[U], Option[V]]:\n    \"\"\"Unzips an option into two options.\n\n    If `self` is [`Some((u, v))`][wraps_core.option.Some], this method returns\n    ([`Some(u)`][wraps_core.option.Some], [`Some(v)`][wraps_core.option.Some]) tuple.\n    Otherwise, ([`Null`][wraps_core.option.Null], [`Null`][wraps_core.option.Null]) is returned.\n\n    Example:\n        ```python\n        value = 13\n        other = 42\n\n        zipped = Some((value, other))\n\n        assert zipped.unzip() == (Some(value), Some(other))\n\n        null = NULL\n\n        assert null.unzip() == (NULL, NULL)\n\n    Returns:\n        The resulting tuple of two options.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.flatten","title":"<code>flatten() -&gt; Option[U]</code>","text":"<p>Flattens an <code>Option[Option[T]]</code> to <code>Option[T]</code>.</p> Example <pre><code>some = Some(42)\nsome_nested = Some(some)\nassert some_nested.flatten() == some\n\nnull = NULL\nnull_nested = Some(null)\nassert null_nested.flatten() == null\n\nassert null.flatten() == null\n</code></pre> <p>Returns:</p> Type Description <code>Option[U]</code> <p>The flattened option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>def flatten(self: OptionProtocol[OptionProtocol[U]]) -&gt; Option[U]:\n    \"\"\"Flattens an [`Option[Option[T]]`][wraps_core.option.Option]\n    to [`Option[T]`][wraps_core.option.Option].\n\n    Example:\n        ```python\n        some = Some(42)\n        some_nested = Some(some)\n        assert some_nested.flatten() == some\n\n        null = NULL\n        null_nested = Some(null)\n        assert null_nested.flatten() == null\n\n        assert null.flatten() == null\n        ```\n\n    Returns:\n        The flattened option.\n    \"\"\"\n    return self.and_then(identity)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.contains","title":"<code>contains(value: U) -&gt; bool</code>","text":"<p>Checks if the contained value (if any) is equal to <code>value</code>.</p> Example <pre><code>value = 42\nother = 69\n\nsome = Some(value)\nassert some.contains(value)\nassert not some.contains(other)\n\nnull = NULL\nassert not null.contains(value)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>U</code> <p>The value to check against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the contained value is equal to <code>value</code>.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef contains(self, value: U) -&gt; bool:\n    \"\"\"Checks if the contained value (if any) is equal to `value`.\n\n    Example:\n        ```python\n        value = 42\n        other = 69\n\n        some = Some(value)\n        assert some.contains(value)\n        assert not some.contains(other)\n\n        null = NULL\n        assert not null.contains(value)\n        ```\n\n    Arguments:\n        value: The value to check against.\n\n    Returns:\n        Whether the contained value is equal to `value`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.OptionProtocol.early","title":"<code>early() -&gt; T</code>","text":"<p>Functionally similar to the question-mark (<code>?</code>) operator in Rust.</p> <p>Calls to this method are to be combined with <code>@early_option</code> decorators to work properly.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@required\ndef early(self) -&gt; T:\n    \"\"\"Functionally similar to the *question-mark* (`?`) operator in Rust.\n\n    Calls to this method are to be combined with\n    [`@early_option`][wraps_core.early.decorators.early_option] decorators to work properly.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps_core.option.Null","title":"<code>Null</code>","text":"<p>               Bases: <code>OptionProtocol[Never]</code></p> <p>The <code>Null</code> variant of <code>Option[T]</code>.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@final\n@frozen()\nclass Null(OptionProtocol[Never]):\n    \"\"\"The [`Null`][wraps_core.option.Null] variant of [`Option[T]`][wraps_core.option.Option].\"\"\"\n\n    def __bool__(self) -&gt; Literal[False]:\n        return False\n\n    def __repr__(self) -&gt; str:\n        return empty_repr(self)\n\n    @classmethod\n    def create(cls) -&gt; Null:\n        return cls()\n\n    def is_some(self) -&gt; Literal[False]:\n        return False\n\n    def is_some_and(self, predicate: Predicate[T]) -&gt; Literal[False]:\n        return False\n\n    async def is_some_and_await(self, predicate: AsyncPredicate[T]) -&gt; Literal[False]:\n        return False\n\n    def is_null(self) -&gt; Literal[True]:\n        return True\n\n    def expect(self, message: str) -&gt; Never:\n        panic(message)\n\n    def extract(self) -&gt; None:\n        return None\n\n    def unwrap(self) -&gt; Never:\n        panic(UNWRAP_ON_NULL)\n\n    def unwrap_or(self, default: U) -&gt; U:\n        return default\n\n    def unwrap_or_else(self, default: Nullary[U]) -&gt; U:\n        return default()\n\n    async def unwrap_or_else_await(self, default: AsyncNullary[U]) -&gt; U:\n        return await default()\n\n    def or_raise(self, error: AnyError) -&gt; Never:\n        raise error\n\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; Never:\n        raise error()\n\n    async def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; Never:\n        raise await error()\n\n    def inspect(self, function: Inspect[T]) -&gt; Null:\n        return self\n\n    async def inspect_await(self, function: AsyncInspect[T]) -&gt; Null:\n        return self\n\n    def map(self, function: Unary[T, U]) -&gt; Null:\n        return self\n\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        return default\n\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        return default()\n\n    async def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        return await default()\n\n    async def map_await(self, function: AsyncUnary[T, U]) -&gt; Null:\n        return self\n\n    async def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        return default\n\n    async def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        return default()\n\n    async def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        return await default()\n\n    def ok_or(self, error: E) -&gt; Error[E]:\n        return Error(error)\n\n    def ok_or_else(self, error: Nullary[E]) -&gt; Error[E]:\n        return Error(error())\n\n    async def ok_or_else_await(self, error: AsyncNullary[E]) -&gt; Error[E]:\n        return Error(await error())\n\n    def iter(self) -&gt; Iterator[Never]:\n        return empty()\n\n    def async_iter(self) -&gt; AsyncIterator[Never]:\n        return async_empty()\n\n    def and_then(self, function: Unary[T, Option[U]]) -&gt; Null:\n        return self\n\n    async def and_then_await(self, function: AsyncUnary[T, Option[U]]) -&gt; Null:\n        return self\n\n    def filter(self, predicate: Predicate[T]) -&gt; Null:\n        return self\n\n    async def filter_await(self, predicate: AsyncPredicate[T]) -&gt; Null:\n        return self\n\n    def or_else(self, default: Nullary[Option[T]]) -&gt; Option[T]:\n        return default()\n\n    async def or_else_await(self, default: AsyncNullary[Option[T]]) -&gt; Option[T]:\n        return await default()\n\n    def xor(self, option: Option[T]) -&gt; Option[T]:\n        return option\n\n    def zip(self, option: Option[U]) -&gt; Null:\n        return self\n\n    def zip_with(self, option: Option[U], function: Binary[T, U, V]) -&gt; Null:\n        return self\n\n    async def zip_with_await(self, option: Option[U], function: AsyncBinary[T, U, V]) -&gt; Null:\n        return self\n\n    def unzip(self) -&gt; Tuple[Null, Null]:\n        return self, self\n\n    def contains(self, value: U) -&gt; Literal[False]:\n        return False\n\n    def early(self) -&gt; Never:\n        raise EarlyOption()\n</code></pre>"},{"location":"reference/option/#wraps_core.option.Some","title":"<code>Some</code>","text":"<p>               Bases: <code>OptionProtocol[T]</code></p> <p><code>Some[T]</code> variant of <code>Option[T]</code>.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@final\n@frozen()\nclass Some(OptionProtocol[T]):\n    \"\"\"[`Some[T]`][wraps_core.option.Some] variant of [`Option[T]`][wraps_core.option.Option].\"\"\"\n\n    value: T\n\n    def __repr__(self) -&gt; str:\n        return wrap_repr(self, self.value)\n\n    @classmethod\n    def create(cls, value: U) -&gt; Some[U]:\n        return cls(value)  # type: ignore[arg-type, return-value]\n\n    def is_some(self) -&gt; Literal[True]:\n        return True\n\n    def is_some_and(self, predicate: Predicate[T]) -&gt; bool:\n        return predicate(self.value)\n\n    async def is_some_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n        return await predicate(self.value)\n\n    def is_null(self) -&gt; Literal[False]:\n        return False\n\n    def expect(self, message: str) -&gt; T:\n        return self.value\n\n    def extract(self) -&gt; T:\n        return self.value\n\n    def unwrap(self) -&gt; T:\n        return self.value\n\n    def unwrap_or(self, default: T) -&gt; T:  # type: ignore[misc]\n        return self.value\n\n    def unwrap_or_else(self, default: Nullary[T]) -&gt; T:\n        return self.value\n\n    def or_raise(self, error: AnyError) -&gt; T:\n        return self.value\n\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n        return self.value\n\n    async def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n        return self.value\n\n    async def unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; T:\n        return self.value\n\n    def inspect(self, function: Inspect[T]) -&gt; Some[T]:\n        function(self.value)\n\n        return self\n\n    async def inspect_await(self, function: AsyncInspect[T]) -&gt; Some[T]:\n        await function(self.value)\n\n        return self\n\n    def map(self, function: Unary[T, U]) -&gt; Some[U]:\n        return self.create(function(self.value))\n\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        return function(self.value)\n\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        return function(self.value)\n\n    async def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        return function(self.value)\n\n    async def map_await(self, function: AsyncUnary[T, U]) -&gt; Some[U]:\n        return self.create(await function(self.value))\n\n    async def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        return await function(self.value)\n\n    async def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        return await function(self.value)\n\n    async def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        return await function(self.value)\n\n    def ok_or(self, error: E) -&gt; Ok[T]:\n        return Ok(self.value)\n\n    def ok_or_else(self, error: Nullary[E]) -&gt; Ok[T]:\n        return Ok(self.value)\n\n    async def ok_or_else_await(self, error: AsyncNullary[E]) -&gt; Ok[T]:\n        return Ok(self.value)\n\n    def iter(self) -&gt; Iterator[T]:\n        return once(self.value)\n\n    def async_iter(self) -&gt; AsyncIterator[T]:\n        return async_once(self.value)\n\n    def and_then(self, function: Unary[T, Option[U]]) -&gt; Option[U]:\n        return function(self.value)\n\n    async def and_then_await(self, function: AsyncUnary[T, Option[U]]) -&gt; Option[U]:\n        return await function(self.value)\n\n    def filter(self, predicate: Predicate[T]) -&gt; Option[T]:\n        return self if predicate(self.value) else NULL\n\n    async def filter_await(self, predicate: AsyncPredicate[T]) -&gt; Option[T]:\n        return self if await predicate(self.value) else NULL\n\n    def or_else(self, default: Nullary[Option[T]]) -&gt; Some[T]:\n        return self\n\n    async def or_else_await(self, default: AsyncNullary[Option[T]]) -&gt; Some[T]:\n        return self\n\n    def xor(self, option: Option[T]) -&gt; Option[T]:\n        return self if is_null(option) else NULL\n\n    @overload\n    def zip(self, option: Null) -&gt; Null: ...\n\n    @overload\n    def zip(self, option: Some[U]) -&gt; Some[Tuple[T, U]]: ...\n\n    @overload\n    def zip(self, option: Option[U]) -&gt; Option[Tuple[T, U]]: ...\n\n    def zip(self, option: Option[U]) -&gt; Option[Tuple[T, U]]:\n        return self.create((self.value, option.value)) if is_some(option) else NULL\n\n    @overload\n    def zip_with(self, option: Null, function: Binary[T, U, V]) -&gt; Null: ...\n\n    @overload\n    def zip_with(self, option: Some[U], function: Binary[T, U, V]) -&gt; Some[V]: ...\n\n    @overload\n    def zip_with(self, option: Option[U], function: Binary[T, U, V]) -&gt; Option[V]: ...\n\n    def zip_with(self, option: Option[U], function: Binary[T, U, V]) -&gt; Option[V]:\n        return self.create(function(self.value, option.value)) if is_some(option) else NULL\n\n    @overload\n    async def zip_with_await(self, option: Null, function: AsyncBinary[T, U, V]) -&gt; Null: ...\n\n    @overload\n    async def zip_with_await(self, option: Some[U], function: AsyncBinary[T, U, V]) -&gt; Some[V]: ...\n\n    @overload\n    async def zip_with_await(\n        self, option: Option[U], function: AsyncBinary[T, U, V]\n    ) -&gt; Option[V]: ...\n\n    async def zip_with_await(self, option: Option[U], function: AsyncBinary[T, U, V]) -&gt; Option[V]:\n        return self.create(await function(self.value, option.value)) if is_some(option) else NULL\n\n    def unzip(self: Some[Tuple[U, V]]) -&gt; Tuple[Some[U], Some[V]]:\n        u, v = self.value\n\n        return self.create(u), self.create(v)\n\n    def contains(self, value: U) -&gt; bool:\n        return self.value == value\n\n    def early(self) -&gt; T:\n        return self.value\n</code></pre>"},{"location":"reference/option/#wraps_core.option.WrapOption","title":"<code>WrapOption</code>","text":"<p>               Bases: <code>Generic[A]</code></p> <p>Wraps functions returning <code>T</code> into functions returning <code>Option[T]</code>.</p> <p>Errors are handled via returning <code>NULL</code> on <code>error</code> of <code>error_types</code>, wrapping the resulting <code>value</code> into <code>Some(value)</code>.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@final\n@frozen()\nclass WrapOption(Generic[A]):\n    \"\"\"Wraps functions returning `T` into functions returning\n    [`Option[T]`][wraps_core.option.Option].\n\n    Errors are handled via returning [`NULL`][wraps_core.option.NULL] on `error` of\n    [`error_types`][wraps_core.option.WrapOption.error_types], wrapping the resulting\n    `value` into [`Some(value)`][wraps_core.option.Some].\n    \"\"\"\n\n    error_types: ErrorTypes[A]\n    \"\"\"The error types to handle. See [`ErrorTypes[A]`][wraps_core.errors.ErrorTypes].\"\"\"\n\n    def __call__(self, function: Callable[P, T]) -&gt; OptionCallable[P, T]:\n        @wraps(function)\n        def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Option[T]:\n            try:\n                return Some(function(*args, **kwargs))\n\n            except self.error_types.extract():\n                return NULL\n\n        return wrap\n</code></pre>"},{"location":"reference/option/#wraps_core.option.WrapOption.error_types","title":"<code>error_types: ErrorTypes[A]</code>  <code>instance-attribute</code>","text":"<p>The error types to handle. See <code>ErrorTypes[A]</code>.</p>"},{"location":"reference/option/#wraps_core.option.WrapOptionAwait","title":"<code>WrapOptionAwait</code>","text":"<p>               Bases: <code>Generic[A]</code></p> <p>Wraps asynchronous functions returning <code>T</code> into functions returning <code>Option[T]</code>.</p> <p>Errors are handled via returning <code>NULL</code> on <code>error</code> of <code>error_types</code>, wrapping the resulting <code>value</code> into <code>Some(value)</code>.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>@final\n@frozen()\nclass WrapOptionAwait(Generic[A]):\n    \"\"\"Wraps asynchronous functions returning `T` into functions returning\n    [`Option[T]`][wraps_core.option.Option].\n\n    Errors are handled via returning [`NULL`][wraps_core.option.NULL] on `error` of\n    [`error_types`][wraps_core.option.WrapOptionAwait.error_types], wrapping the resulting\n    `value` into [`Some(value)`][wraps_core.option.Some].\n    \"\"\"\n\n    error_types: ErrorTypes[A]\n    \"\"\"The error types to handle. See [`ErrorTypes[A]`][wraps_core.errors.ErrorTypes].\"\"\"\n\n    def __call__(self, function: AsyncCallable[P, T]) -&gt; OptionAsyncCallable[P, T]:\n        @wraps(function)\n        async def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Option[T]:\n            try:\n                return Some(await function(*args, **kwargs))\n\n            except self.error_types.extract():\n                return NULL\n\n        return wrap\n</code></pre>"},{"location":"reference/option/#wraps_core.option.WrapOptionAwait.error_types","title":"<code>error_types: ErrorTypes[A]</code>  <code>instance-attribute</code>","text":"<p>The error types to handle. See <code>ErrorTypes[A]</code>.</p>"},{"location":"reference/option/#wraps_core.option.is_some","title":"<code>is_some(option: Option[T]) -&gt; TypeIs[Some[T]]</code>","text":"<p>This is the same as <code>Option.is_some</code>, except it works as a type guard.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>def is_some(option: Option[T]) -&gt; TypeIs[Some[T]]:\n    \"\"\"This is the same as [`Option.is_some`][wraps_core.option.OptionProtocol.is_some],\n    except it works as a *type guard*.\n    \"\"\"\n    return option.is_some()\n</code></pre>"},{"location":"reference/option/#wraps_core.option.is_null","title":"<code>is_null(option: Option[T]) -&gt; TypeIs[Null]</code>","text":"<p>This is the same as <code>Option.is_null</code>, except it works as a type guard.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>def is_null(option: Option[T]) -&gt; TypeIs[Null]:\n    \"\"\"This is the same as [`Option.is_null`][wraps_core.option.OptionProtocol.is_null],\n    except it works as a *type guard*.\n    \"\"\"\n    return option.is_null()\n</code></pre>"},{"location":"reference/option/#wraps_core.option.wrap_optional","title":"<code>wrap_optional(optional: Optional[T]) -&gt; Option[T]</code>","text":"<p>Wraps <code>Optional[T]</code> into <code>Option[T]</code>.</p> <p>If the argument is <code>None</code>, <code>NULL</code> is returned. Otherwise the <code>value</code> (of type <code>T</code>) is wrapped into <code>Some(value)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>optional</code> <code>Optional[T]</code> <p>The optional value to wrap.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The wrapped option.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>def wrap_optional(optional: Optional[T]) -&gt; Option[T]:\n    \"\"\"Wraps [`Optional[T]`][typing.Optional] into [`Option[T]`][wraps_core.option.Option].\n\n    If the argument is [`None`][None], [`NULL`][wraps_core.option.NULL] is returned.\n    Otherwise the `value` (of type `T`) is wrapped into [`Some(value)`][wraps_core.option.Some].\n\n    Arguments:\n        optional: The optional value to wrap.\n\n    Returns:\n        The wrapped option.\n    \"\"\"\n    return NULL if optional is None else Some(optional)\n</code></pre>"},{"location":"reference/option/#wraps_core.option.wrap_option_on","title":"<code>wrap_option_on(head: Type[A], *tail: Type[A]) -&gt; WrapOption[A]</code>","text":"<p>Creates <code>WrapOption[A]</code> decorators.</p> <p>This function enforces at least one error type to be provided.</p> Example <pre><code>@wrap_option_on(ValueError)\ndef parse(string: str) -&gt; int:\n    return int(string)\n\nassert parse(\"256\").is_some()\nassert parse(\"uwu\").is_null()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>head</code> <code>Type[A]</code> <p>The head of the error types to handle.</p> required <code>*tail</code> <code>Type[A]</code> <p>The tail of the error types to handle.</p> <code>()</code> <p>Returns:</p> Type Description <code>WrapOption[A]</code> <p>The <code>WrapOption[A]</code> decorator created.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>def wrap_option_on(head: Type[A], *tail: Type[A]) -&gt; WrapOption[A]:\n    \"\"\"Creates [`WrapOption[A]`][wraps_core.option.WrapOption] decorators.\n\n    This function enforces at least one error type to be provided.\n\n    Example:\n        ```python\n        @wrap_option_on(ValueError)\n        def parse(string: str) -&gt; int:\n            return int(string)\n\n        assert parse(\"256\").is_some()\n        assert parse(\"uwu\").is_null()\n        ```\n\n    Arguments:\n        head: The head of the error types to handle.\n        *tail: The tail of the error types to handle.\n\n    Returns:\n        The [`WrapOption[A]`][wraps_core.option.WrapOption] decorator created.\n    \"\"\"\n    return WrapOption(ErrorTypes[A].from_head_and_tail(head, *tail))\n</code></pre>"},{"location":"reference/option/#wraps_core.option.wrap_option_await_on","title":"<code>wrap_option_await_on(head: Type[A], *tail: Type[A]) -&gt; WrapOptionAwait[A]</code>","text":"<p>Creates <code>WrapOptionAwait[A]</code> decorators.</p> <p>This function enforces at least one error type to be provided.</p> Example <pre><code>@wrap_option_await_on(ValueError)\nasync def parse(string: str) -&gt; int:\n    return int(string)\n\nassert (await parse(\"256\")).is_some()\nassert (await parse(\"uwu\")).is_null()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>head</code> <code>Type[A]</code> <p>The head of the error types to handle.</p> required <code>*tail</code> <code>Type[A]</code> <p>The tail of the error types to handle.</p> <code>()</code> <p>Returns:</p> Type Description <code>WrapOptionAwait[A]</code> <p>The <code>WrapOptionAwait[A]</code> decorator created.</p> Source code in <code>src/wraps_core/option.py</code> <pre><code>def wrap_option_await_on(head: Type[A], *tail: Type[A]) -&gt; WrapOptionAwait[A]:\n    \"\"\"Creates [`WrapOptionAwait[A]`][wraps_core.option.WrapOptionAwait] decorators.\n\n    This function enforces at least one error type to be provided.\n\n    Example:\n        ```python\n        @wrap_option_await_on(ValueError)\n        async def parse(string: str) -&gt; int:\n            return int(string)\n\n        assert (await parse(\"256\")).is_some()\n        assert (await parse(\"uwu\")).is_null()\n        ```\n\n    Arguments:\n        head: The head of the error types to handle.\n        *tail: The tail of the error types to handle.\n\n    Returns:\n        The [`WrapOptionAwait[A]`][wraps_core.option.WrapOptionAwait] decorator created.\n    \"\"\"\n    return WrapOptionAwait(ErrorTypes[A].from_head_and_tail(head, *tail))\n</code></pre>"},{"location":"reference/panics/","title":"Panics","text":"<p>Panics represented as errors.</p>"},{"location":"reference/panics/#wraps_core.panics.Panic","title":"<code>Panic</code>","text":"<p>               Bases: <code>AnyError</code></p> <p>Represents panics as errors.</p> <p>Panics should not be explicitly handled in general, therefore <code>Panic</code> is derived from <code>AnyError</code>.</p> Source code in <code>src/wraps_core/panics.py</code> <pre><code>class Panic(AnyError):\n    \"\"\"Represents panics as errors.\n\n    Panics should not be explicitly handled in general, therefore [`Panic`][wraps_core.panics.Panic]\n    is derived from [`AnyError`][typing_aliases.AnyError].\n    \"\"\"\n\n    def __init__(self, message: Optional[str] = None) -&gt; None:\n        self._message = message\n\n        if message is None:\n            message = PANIC\n\n        super().__init__(message)\n\n    @property\n    def message(self) -&gt; Optional[str]:\n        return self._message\n</code></pre>"},{"location":"reference/panics/#wraps_core.panics.panic","title":"<code>panic(message: Optional[str] = None) -&gt; Never</code>","text":"<p>Panics with the optional message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>The message to panic with.</p> <code>None</code> <p>Raises:</p> Type Description <code>Panic</code> <p>Always raised.</p> Source code in <code>src/wraps_core/panics.py</code> <pre><code>def panic(message: Optional[str] = None) -&gt; Never:\n    \"\"\"Panics with the optional message.\n\n    Arguments:\n        message: The message to panic with.\n\n    Raises:\n        Panic: Always raised.\n    \"\"\"\n    raise Panic(message)\n</code></pre>"},{"location":"reference/result/","title":"Result","text":"<p>Error handling with the <code>Result[T, E]</code> type.</p> <p><code>Result[T, E]</code> is the type used for returning and propagating errors.</p> <p>It is an enum with the variants, <code>Ok[T]</code>, representing success and containing a value, and <code>Error[E]</code>, representing error and containing an error value.</p> <p>Functions return <code>Result[T, E]</code> whenever errors are expected and recoverable.</p> <p>For instance, our <code>divide</code> function from the <code>option</code> section:</p> <pre><code># result.py\n\nfrom enum import Enum\n\nfrom wraps import Error, Ok, Result\n\n\nclass DivideError(Enum):\n    DIVISION_BY_ZERO = \"division by zero\"\n\n\ndef divide(numerator: float, denominator: float) -&gt; Result[float, DivideError]:\n    return Ok(numerator / denominator) if denominator else Error(DivideError.DIVISION_BY_ZERO)\n</code></pre> <pre><code>from wraps import Error, Ok\n\nfrom result import divide\n\nresult = divide(1.0, 2.0)\n\nmatch result:\n    case Ok(value):\n        print(value)\n\n    case Error(error):\n        print(error)\n</code></pre>"},{"location":"reference/result/#wraps_core.result.Result","title":"<code>Result = Union[Ok[T], Error[E]]</code>  <code>module-attribute</code>","text":"<p>Result value, expressed as the union of <code>Ok[T]</code> and <code>Error[E]</code>.</p>"},{"location":"reference/result/#wraps_core.result.wrap_result","title":"<code>wrap_result = wrap_result_on(NormalError)</code>  <code>module-attribute</code>","text":"<p>An instance of <code>WrapResult[NormalError]</code> (see <code>NormalError</code>).</p>"},{"location":"reference/result/#wraps_core.result.wrap_result_await","title":"<code>wrap_result_await = wrap_result_await_on(NormalError)</code>  <code>module-attribute</code>","text":"<p>An instance of <code>WrapResultAwait[NormalError]</code> (see <code>NormalError</code>).</p>"},{"location":"reference/result/#wraps_core.result.ResultProtocol","title":"<code>ResultProtocol</code>","text":"<p>               Bases: <code>AsyncIterable[T]</code>, <code>Iterable[T]</code>, <code>Protocol[T, E]</code></p> Source code in <code>src/wraps_core/result.py</code> <pre><code>class ResultProtocol(AsyncIterable[T], Iterable[T], Protocol[T, E]):  # type: ignore[misc]\n    def __iter__(self) -&gt; Iterator[T]:\n        return self.iter()\n\n    def __aiter__(self) -&gt; AsyncIterator[T]:\n        return self.async_iter()\n\n    @required\n    def is_ok(self) -&gt; bool:\n        \"\"\"Checks if the result is [`Ok[T]`][wraps_core.result.Ok].\n\n        Example:\n            ```python\n            ok = Ok(42)\n            assert ok.is_ok()\n\n            error = Error(13)\n            assert not error.is_ok()\n            ```\n\n        Returns:\n            Whether the result is [`Ok[T]`][wraps_core.result.Ok].\n        \"\"\"\n        ...\n\n    @required\n    def is_ok_and(self, predicate: Predicate[T]) -&gt; bool:\n        \"\"\"Checks if the result is [`Ok[T]`][wraps_core.result.Ok] and the value\n        inside of it matches the `predicate`.\n\n        Example:\n            ```python\n            def is_positive(value: int) -&gt; bool:\n                return value &gt; 0\n\n            ok = Ok(13)\n            assert ok.is_ok_and(is_positive)\n\n            zero = Ok(0)\n            assert not zero.is_ok_and(is_positive)\n\n            error = Error(7)\n            assert not error.is_ok_and(is_positive)\n            ```\n\n        Arguments:\n            predicate: The predicate to check the contained value against.\n\n        Returns:\n            Whether the result is [`Ok[T]`][wraps_core.result.Ok] and the predicate is matched.\n        \"\"\"\n        ...\n\n    @required\n    async def is_ok_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n        \"\"\"Checks if the result is [`Ok[T]`][wraps_core.result.Ok] and the value\n        inside of it matches the asynchronous `predicate`.\n\n        Example:\n            ```python\n            async def is_positive(value: int) -&gt; bool:\n                return value &gt; 0\n\n            ok = Ok(13)\n            assert await ok.is_ok_and_await(is_positive)\n\n            zero = Ok(0)\n            assert not await zero.is_ok_and_await(is_positive)\n\n            error = Error(7)\n            assert not await error.is_ok_and_await(is_positive)\n            ```\n\n        Arguments:\n            predicate: The asynchronous predicate to check the contained value against.\n\n        Returns:\n            Whether the result is [`Ok[T]`][wraps_core.result.Ok] and\n            the asynchronous predicate is matched.\n        \"\"\"\n        ...\n\n    @required\n    def is_error(self) -&gt; bool:\n        \"\"\"Checks if the result is [`Error[E]`][wraps_core.result.Error].\n\n        Example:\n            ```python\n            error = Error(34)\n            assert error.is_error()\n\n            ok = Ok(69)\n            assert not ok.is_error()\n            ```\n\n        Returns:\n            Whether the result is [`Error[E]`][wraps_core.result.Error].\n        \"\"\"\n        ...\n\n    @required\n    def is_error_and(self, predicate: Predicate[E]) -&gt; bool:\n        \"\"\"Checks if the result is [`Error[E]`][wraps_core.result.Error] and the value\n        inside of it matches the `predicate`.\n\n        Example:\n            ```python\n            def is_negative(value: int) -&gt; bool:\n                return value &lt; 0\n\n            error = Error(-13)\n            assert error.is_error_and(is_positive)\n\n            zero = Error(0)\n            assert not zero.is_error_and(is_positive)\n\n            ok = Ok(7)\n            assert not ok.is_error_and(is_positive)\n            ```\n\n        Arguments:\n            predicate: The predicate to check the contained value against.\n\n        Returns:\n            Whether the result is [`Error[E]`][wraps_core.result.Error] and the predicate is matched.\n        \"\"\"\n        ...\n\n    @required\n    async def is_error_and_await(self, predicate: AsyncPredicate[E]) -&gt; bool:\n        \"\"\"Checks if the result is [`Error[E]`][wraps_core.result.Error] and the value\n        inside of it matches the asynchronous `predicate`.\n\n        Example:\n            ```python\n            async def is_negative(value: int) -&gt; bool:\n                return value &lt; 0\n\n            error = Error(-13)\n            assert await error.is_error_and_await(is_negative)\n\n            zero = Error(0)\n            assert not await zero.is_error_and_await(is_negative)\n\n            ok = Ok(7)\n            assert not await ok.is_error_and_await(is_negative)\n            ```\n\n        Arguments:\n            predicate: The asynchronous predicate to check the contained value against.\n\n        Returns:\n            Whether the result is [`Error[E]`][wraps_core.result.Error] and\n            the asynchronous predicate is matched.\n        \"\"\"\n        ...\n\n    @required\n    def expect(self, message: str) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; ok = Ok(42)\n            &gt;&gt;&gt; ok.expect(\"error!\")\n            42\n            &gt;&gt;&gt; error = Error(0)\n            &gt;&gt;&gt; error.expect(\"error!\")\n            Traceback (most recent call last):\n              ...\n            wraps_core.panics.Panic: error!\n            ```\n\n        Arguments:\n            message: The message used in panicking.\n\n        Raises:\n            Panic: Panics with the `message` if the result is [`Error[E]`][wraps_core.result.Error].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def expect_error(self, message: str) -&gt; E:\n        \"\"\"Returns the contained [`Error[E]`][wraps_core.result.Error] value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; ok = Ok(42)\n            &gt;&gt;&gt; ok.expect_error(\"ok!\")\n            Traceback (most recent call last):\n              ...\n            wraps_core.panics.Panic: ok!\n\n            &gt;&gt;&gt; error = Error(0)\n            &gt;&gt;&gt; error.expect_error(\"ok!\")\n            0\n            ```\n\n        Arguments:\n            message: The message used in panicking.\n\n        Raises:\n            Panic: Panics with the `message` if the result is [`Ok[T]`][wraps_core.result.Ok].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap(self) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value (of type `T`).\n\n        Because this function may panic, its use is generally discouraged.\n\n        Instead, prefer to use pattern matching and handle the [`Error[E]`][wraps_core.result.Error]\n        case explicitly, or call [`unwrap_or`][wraps_core.result.ResultProtocol.unwrap_or]\n        or [`unwrap_or_else`][wraps_core.result.ResultProtocol.unwrap_or_else].\n\n        Example:\n            ```python\n            &gt;&gt;&gt; ok = Ok(13)\n            &gt;&gt;&gt; ok.unwrap()\n            13\n\n            &gt;&gt;&gt; error = Error(0)\n            &gt;&gt;&gt; error.unwrap()\n            Traceback (most recent call last):\n              ...\n            wraps_core.panics.Panic: called `unwrap` on error\n            ```\n\n        Raises:\n            Panic: Panics if the result is [`Error[E]`][wraps_core.result.Error].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_or(self, default: T) -&gt; T:  # type: ignore[misc]\n        \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value or the provided `default`.\n\n        Example:\n            ```python\n            ok = Ok(69)\n            assert ok.unwrap_or(0)\n\n            error = Error(13)\n            assert not error.unwrap_or(0)\n            ```\n\n        Arguments:\n            default: The default value to use.\n\n        Returns:\n            The contained value or the `default` one.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_or_else(self, default: Nullary[T]) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value\n        or computes it from the `default` function.\n\n        Example:\n            ```python\n            ok = Ok(5)\n            assert ok.unwrap_or_else(int)\n\n            error = Error(8)\n            assert not error.unwrap_or_else(int)\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n\n        Returns:\n            The contained value or the `default()` one.\n        \"\"\"\n        ...\n\n    @required\n    async def unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value\n        or computes it from the asynchronous `default` function.\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 0\n\n            ok = Ok(5)\n            assert await ok.unwrap_or_else_await(default)\n\n            error = Error(8)\n            assert not await error.unwrap_or_else_await(default)\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n\n        Returns:\n            The contained value or the `await default()` one.\n        \"\"\"\n        ...\n\n    @required\n    def or_raise(self, error: AnyError) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value\n        or raises the `error` provided.\n\n        Arguments:\n            error: The error to raise if the result is [`Error[E]`][wraps_core.result.Error].\n\n        Raises:\n            AnyError: The error provided, if the result is [`Error[E]`][wraps_core.result.Error].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value\n        or raises the error computed from `error`.\n\n        Arguments:\n            error: The error to raise if the result is [`Error[E]`][wraps_core.result.Error].\n\n        Raises:\n            AnyError: The error computed, if the result is\n                [`Error[E]`][wraps_core.result.Error].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    async def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value\n        or raises the error computed asynchronously from `error`.\n\n        Arguments:\n            error: The error to raise if the result is [`Error[E]`][wraps_core.result.Error].\n\n        Raises:\n            AnyError: The error computed, if the result is\n                [`Error[E]`][wraps_core.result.Error].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_error(self) -&gt; E:\n        \"\"\"Returns the contained [`Error[E]`][wraps_core.result.Error] value.\n\n        Because this function may panic, its use is generally discouraged.\n\n        Instead, prefer to use pattern matching and handle the [`Ok[T]`][wraps_core.result.Ok]\n        case explicitly, or call [`unwrap_error_or`][wraps_core.result.ResultProtocol.unwrap_error_or]\n        or [`unwrap_error_or_else`][wraps_core.result.ResultProtocol.unwrap_error_or_else].\n\n        Example:\n            ```python\n            &gt;&gt;&gt; error = Error(13)\n            &gt;&gt;&gt; error.unwrap_error()\n            13\n\n            &gt;&gt;&gt; ok = Ok(42)\n            &gt;&gt;&gt; ok.unwrap_error()\n            Traceback (most recent call last):\n              ...\n            wraps_core.panics.Panic: called `unwrap_error` on ok\n            ```\n\n        Raises:\n            Panic: Panics if the result is [`Ok[T]`][wraps_core.result.Ok].\n\n        Returns:\n            The contained error value.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_error_or(self, default: E) -&gt; E:  # type: ignore[misc]\n        \"\"\"Returns the contained [`Error[E]`][wraps_core.result.Error] value (of type `E`)\n        or a provided default.\n\n        Example:\n            ```python\n            error = Error(1)\n            assert error.unwrap_error_or(0)\n\n            ok = Ok(2)\n            assert not ok.unwrap_error_or(0)\n            ```\n\n        Arguments:\n            default: The default value to use.\n\n        Returns:\n            The contained error value or the `default` one.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_error_or_else(self, default: Nullary[E]) -&gt; E:\n        \"\"\"Returns the contained [`Error[E]`][wraps_core.result.Error] value\n        or computes it from the `default` function.\n\n        Example:\n            ```python\n            error = Error(5)\n            assert error.unwrap_error_or_else(int)\n\n            ok = Ok(8)\n            assert not ok.unwrap_error_or_else(int)\n\n        Arguments:\n            default: The default-computing function to use.\n\n        Returns:\n            The contained error value or the `default()` one.\n        \"\"\"\n        ...\n\n    @required\n    async def unwrap_error_or_else_await(self, default: AsyncNullary[E]) -&gt; E:\n        \"\"\"Returns the contained [`Error[E]`][wraps_core.result.Error] value\n        or computes it from the asynchronous `default` function.\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 0\n\n            error = Error(13)\n            assert await error.unwrap_error_or_else_await(default)\n\n            ok = Ok(5)\n            assert not await ok.unwrap_error_or_else_await(default)\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n\n        Returns:\n            The contained error value or the `await default()` one.\n        \"\"\"\n        ...\n\n    @required\n    def raising(self: ResultProtocol[T, AnyError]) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value or raises the\n        contained [`Error[AnyError]`][wraps_core.result.Error] value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; ok = Ok(13)\n            &gt;&gt;&gt; ok.raising()\n            13\n\n            &gt;&gt;&gt; error = Error(ValueError(\"error...\"))\n            &gt;&gt;&gt; error.raising()\n            Traceback (most recent call last):\n              ...\n            ValueError: error...\n            ```\n\n        Raises:\n            AnyError: The contained error, if the result is [`Error[AnyError]`][wraps_core.result.Error].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def ok(self) -&gt; Option[T]:\n        \"\"\"Converts a [`Result[T, E]`][wraps_core.result.Result]\n        into an [`Option[T]`][wraps_core.option.Option].\n\n        Converts `self` into an [`Option[T]`][wraps_core.option.Option], discarding errors, if any.\n\n        Example:\n            ```python\n            ok = Ok(42)\n\n            assert ok.ok().is_some()\n\n            error = Error(0)\n\n            assert error.ok().is_null()\n            ```\n\n        Returns:\n            The converted option.\n        \"\"\"\n        ...\n\n    @required\n    def error(self) -&gt; Option[E]:\n        \"\"\"Converts a [`Result[T, E]`][wraps_core.result.Result]\n        into an [`Option[E]`][wraps_core.option.Option].\n\n        Converts `self` into an [`Option[E]`][wraps_core.option.Option],\n        discarding success values, if any.\n\n        Example:\n            ```python\n            error = Error(13)\n\n            assert error.error().is_some()\n\n            ok = Ok(2)\n\n            assert ok.error().is_null()\n            ```\n\n        Returns:\n            The converted option.\n        \"\"\"\n        ...\n\n    @required\n    def inspect(self, function: Inspect[T]) -&gt; Result[T, E]:\n        \"\"\"Inspects a possibly contained [`Ok[T]`][wraps_core.result.Ok] value.\n\n        Example:\n            ```python\n            ok = Ok(\"Hello, world!\")\n\n            same = ok.inspect(print)  # Hello, world!\n\n            assert ok == same\n            ```\n\n        Arguments:\n            function: The inspecting function.\n\n        Returns:\n            The inspected result.\n        \"\"\"\n        ...\n\n    @required\n    async def inspect_await(self, function: AsyncInspect[T]) -&gt; Result[T, E]:\n        \"\"\"Inspects a possibly contained [`Ok[T]`][wraps_core.result.Ok] value.\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; None:\n                print(value)\n\n            ok = Ok(\"Hello, world!\")\n\n            same = await ok.inspect_await(function)  # Hello, world!\n\n            assert ok == same\n            ```\n\n        Arguments:\n            function: The asynchronous inspecting function.\n\n        Returns:\n            The inspected result.\n        \"\"\"\n        ...\n\n    @required\n    def inspect_error(self, function: Inspect[E]) -&gt; Result[T, E]:\n        \"\"\"Inspects a possibly contained [`Error[E]`][wraps_core.result.Error] value.\n\n        Example:\n            ```python\n            error = Error(\"Bye, world!\")\n\n            same = error.inspect_error(print)  # Bye, world!\n\n            assert error == same\n            ```\n\n        Arguments:\n            function: The error-inspecting function.\n\n        Returns:\n            The inspected result.\n        \"\"\"\n        ...\n\n    @required\n    async def inspect_error_await(self, function: AsyncInspect[E]) -&gt; Result[T, E]:\n        \"\"\"Inspects a possibly contained [`Error[E]`][wraps_core.result.Error] value.\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; None:\n                print(value)\n\n            error = Error(\"Bye, world!\")\n\n            same = await error.inspect_error_await(function)  # Bye, world!\n\n            assert error == same\n            ```\n\n        Arguments:\n            function: The asynchronous error-inspecting function.\n\n        Returns:\n            The inspected result.\n        \"\"\"\n        ...\n\n    @required\n    def map(self, function: Unary[T, U]) -&gt; Result[U, E]:\n        \"\"\"Maps a [`Result[T, E]`][wraps_core.result.Result] to a [`Result[U, E]`][wraps_core.result.Result]\n        by applying `function` to the contained [`Ok[T]`][wraps_core.result.Ok] value,\n        leaving any [`Error[E]`][wraps_core.result.Error] values untouched.\n\n        This function can be used to compose the results of two functions.\n\n        Example:\n            ```python\n            value = 69\n            mapped = \"69\"\n\n            ok = Ok(value)\n\n            assert ok.map(str) == Ok(mapped)\n\n            error = Error(0)\n\n            assert error.map(str) == error\n            ```\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The mapped result.\n        \"\"\"\n        ...\n\n    @required\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        \"\"\"Returns the default value (if errored), or applies the `function`\n        to the contained value (if succeeded).\n\n        Example:\n            ```python\n            ok = Ok(\"Hello, world!\")\n            print(ok.map_or(42, len))  # 13\n\n            error = Error(\"error...\")\n            print(error.map_or(42, len))  # 42\n            ```\n\n        Arguments:\n            default: The default value to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting or the default value.\n        \"\"\"\n        ...\n\n    @required\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        \"\"\"Computes the default value (if errored), or applies the `function`\n        to the contained value (if succeeded).\n\n        Example:\n            ```python\n            ok = Ok(\"Hello, world!\")\n            print(ok.map_or_else(int, len))  # 13\n\n            error = Error(\"error!\")\n            print(error.map_or_else(int, len))  # 0\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting or the default computed value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        \"\"\"Computes the default value (if errored), or applies the `function`\n        to the contained value (if succeeded).\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 0\n\n            ok = Ok(\"Hello, world!\")\n            print(await ok.map_or_else_await(default, len))  # 13\n\n            error = Error(\"error!\")\n            print(await error.map_or_else_await(default, len))  # 0\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting or the default computed value.\n        \"\"\"\n        ...\n\n    @required\n    def map_error(self, function: Unary[E, F]) -&gt; Result[T, F]:\n        \"\"\"Maps a [`Result[T, E]`][wraps_core.result.Result] to a [`Result[T, F]`][wraps_core.result.Result]\n        by applying the `function` to the contained [`Error[E]`][wraps_core.result.Error] value,\n        leaving any [`Ok[T]`][wraps_core.result.Ok] values untouched.\n\n        Example:\n            ```python\n            value = 42\n            mapped = \"42\"\n\n            error = Error(value)\n\n            assert error.map_error(str) == Error(mapped)\n\n            ok = Ok(2)\n\n            assert ok.map_error(str) == ok\n            ```\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The mapped result.\n        \"\"\"\n        ...\n\n    @required\n    def map_error_or(self, default: F, function: Unary[E, F]) -&gt; F:\n        \"\"\"Returns the default value (if succeeded), or applies the `function`\n        to the contained error value (if errored).\n\n        Example:\n            ```python\n            error = Error(\"nekit\")\n            print(error.map_error_or(13, len))  # 5\n\n            ok = Ok(\"ok\")\n            print(error.map_error_or(13, len))  # 13\n            ```\n\n        Arguments:\n            default: The default value to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting or the default value.\n        \"\"\"\n        ...\n\n    @required\n    def map_error_or_else(self, default: Nullary[F], function: Unary[E, F]) -&gt; F:\n        \"\"\"Computes the default value (if succeeded), or applies the `function`\n        to the contained value (if errored).\n\n        Example:\n            ```python\n            error = Error(\"error...\")\n            print(error.map_error_or_else(int, len))  # 8\n\n            ok = Ok(\"ok!\")\n            print(ok.map_error_or_else(int, len))  # 0\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting or the computed default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_error_or_else_await(self, default: AsyncNullary[F], function: Unary[E, F]) -&gt; F:\n        \"\"\"Computes the default value (if succeeded), or applies the `function`\n        to the contained value (if errored).\n\n        Example:\n            ```python\n            error = Error(\"error...\")\n            print(await error.map_error_or_else(int, len))  # 8\n\n            ok = Ok(\"ok!\")\n            print(await ok.map_error_or_else(int, len))  # 0\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting or the computed default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await(self, function: AsyncUnary[T, U]) -&gt; Result[U, E]:\n        \"\"\"Maps a [`Result[T, E]`][wraps_core.result.Result] to a [`Result[U, E]`][wraps_core.result.Result]\n        by applying the asynchronous `function` to the contained [`Ok[T]`][wraps_core.result.Ok] value,\n        leaving any [`Error[E]`][wraps_core.result.Error] values untouched.\n\n        This function can be used to compose the results of two functions.\n\n        Example:\n            ```python\n            async def function(value: int) -&gt; str:\n                return str(value)\n\n            value = 69\n            mapped = \"69\"\n\n            ok = Ok(value)\n\n            assert await ok.map_await(function) == Ok(mapped)\n\n            error = Error(0)\n\n            assert await error.map_await(function) == error\n            ```\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The mapped result.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        \"\"\"Returns the default value (if errored), or applies the asynchronous `function`\n        to the contained value (if succeeded).\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            ok = Ok(\"Hello, world!\")\n            print(await ok.map_await_or(42, function))  # 13\n\n            error = Error(\"error...\")\n            print(error.map_await_or(42, function))  # 42\n            ```\n\n        Arguments:\n            default: The default value to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting or the default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        \"\"\"Computes the default value (if errored), or applies the asynchronous `function`\n        to the contained value (if succeeded).\n\n        Example:\n            ```python\n            async def async_len(value: str) -&gt; int:\n                return len(value)\n\n            ok = Ok(\"Hello, world!\")\n            print(await ok.map_await_or_else(int, async_len))  # 13\n\n            error = Error(\"error!\")\n            print(await error.map_await_or_else(int, async_len))  # 0\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting or the computed default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        \"\"\"Computes the default value (if errored), or applies the asynchronous `function`\n        to the contained value (if succeeded).\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 0\n\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            ok = Ok(\"Hello, world!\")\n            print(await ok.map_await_or_else_await(default, function))  # 13\n\n            error = Error(\"error!\")\n            print(await error.map_await_or_else_await(default, function))  # 0\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting or the computed default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_error_await(self, function: AsyncUnary[E, F]) -&gt; Result[T, F]:\n        \"\"\"Maps a [`Result[T, E]`][wraps_core.result.Result] to a [`Result[T, F]`][wraps_core.result.Result]\n        by applying the asynchronous `function` to the contained [`Error[E]`][wraps_core.result.Error]\n        value, leaving any [`Ok[T]`][wraps_core.result.Ok] values untouched.\n\n        Example:\n            ```python\n            async def function(value: int) -&gt; str:\n                return str(value)\n\n            value = 42\n            mapped = \"42\"\n\n            error = Error(value)\n\n            assert await error.map_error_await(function) == Error(mapped)\n\n            ok = Ok(13)\n\n            assert await ok.map_error_await(function) == ok\n            ```\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The mapped result.\n        \"\"\"\n        ...\n\n    @required\n    async def map_error_await_or(self, default: F, function: AsyncUnary[E, F]) -&gt; F:\n        \"\"\"Returns the default value (if succeeded), or applies the asynchronous `function`\n        to the contained value (if errored).\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            error = Error(\"Bye, world!\")\n            print(await error.map_error_await_or(42, function))  # 11\n\n            ok = Ok(\"Hello, world!\")\n            print(await ok.map_error_await_or(42, function))  # 42\n            ```\n\n        Arguments:\n            default: The default value to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting or the default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_error_await_or_else(self, default: Nullary[F], function: AsyncUnary[E, F]) -&gt; F:\n        \"\"\"Computes the default value (if succeeded), or applies the asynchronous `function`\n        to the contained value (if errored).\n\n        Example:\n            ```python\n            async def async_len(value: str) -&gt; int:\n                return len(value)\n\n            error = Error(\"Bye, world!\")\n            print(await error.map_error_await_or_else(int, async_len))  # 11\n\n            ok = Ok(\"Hello, world!\")\n            print(await ok.map_error_await_or_else(int, async_len))  # 0\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting or the computed default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_error_await_or_else_await(\n        self, default: AsyncNullary[F], function: AsyncUnary[E, F]\n    ) -&gt; F:\n        \"\"\"Computes the default value (if succeeded), or applies the asynchronous `function`\n        to the contained value (if errored).\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 0\n\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            error = Error(\"error\")\n            print(await error.map_error_await_or_else_await(default, function))  # 5\n\n            ok = Ok(\"ok\")\n            print(await ok.map_error_await_or_else_await(default, function))  # 0\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting or the default computed value.\n        \"\"\"\n        ...\n\n    @required\n    def iter(self) -&gt; Iterator[T]:\n        \"\"\"Returns an iterator over the possibly contained value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; ok = Ok(42)\n            &gt;&gt;&gt; next(ok.iter(), 0)\n            42\n            &gt;&gt;&gt; error = Error(13)\n            &gt;&gt;&gt; next(error.iter(), 0)\n            0\n            ```\n\n        Returns:\n            An iterator over the possibly contained value.\n        \"\"\"\n        ...\n\n    @required\n    def iter_error(self) -&gt; Iterator[E]:\n        \"\"\"Returns an iterator over the possibly contained error value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; error = Error(13)\n            &gt;&gt;&gt; next(error.iter_error(), 0)\n            13\n            &gt;&gt;&gt; ok = Ok(1)\n            &gt;&gt;&gt; next(ok.iter_error(), 0)\n            0\n            ```\n\n        Returns:\n            An iterator over the possibly contained error value.\n        \"\"\"\n        ...\n\n    @required\n    def async_iter(self) -&gt; AsyncIterator[T]:\n        \"\"\"Returns an asynchronous iterator over the possibly contained\n        [`Ok[T]`][wraps_core.result.Ok] value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; ok = Ok(42)\n            &gt;&gt;&gt; await async_next(ok.async_iter(), 0)\n            42\n            &gt;&gt;&gt; error = Error(13)\n            &gt;&gt;&gt; await async_next(error.async_iter(), 0)\n            0\n            ```\n\n        Returns:\n            An asynchronous iterator over the possibly contained value.\n        \"\"\"\n        ...\n\n    @required\n    def async_iter_error(self) -&gt; AsyncIterator[E]:\n        \"\"\"Returns an asynchronous iterator over the possibly contained\n        [`Error[E]`][wraps_core.result.Error] value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; error = Error(42)\n            &gt;&gt;&gt; await async_next(error.async_iter_error(), 0)\n            42\n            &gt;&gt;&gt; ok = Ok(13)\n            &gt;&gt;&gt; await async_next(ok.async_iter_error(), 0)\n            0\n            ```\n\n        Returns:\n            An asynchronous iterator over the possibly contained error value.\n        \"\"\"\n        ...\n\n    @required\n    def and_then(self, function: Unary[T, Result[U, E]]) -&gt; Result[U, E]:\n        \"\"\"Returns the result if it is an [`Error[E]`][wraps_core.result.Error],\n        otherwise calls the `function` with the wrapped value and returns the result.\n\n        This function is also known as *bind* in functional programming.\n\n        Example:\n            ```python\n            class InverseError(Enum):\n                DIVISION_BY_ZERO = \"division by zero\"\n\n            def inverse(value: float) -&gt; Result[float, InverseError]:\n                return Ok(1.0 / value) if value else Error(InverseError.DIVISION_BY_ZERO)\n\n            two = Ok(2.0)\n            print(two.and_then(inverse).unwrap())  # 0.5\n\n            zero = Ok(0.0)\n            print(zero.and_then(inverse).unwrap_error())  # division by zero\n\n            error = Error(1.0)\n            print(error.and_then(inverse).unwrap_error())  # 1.0\n            ```\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The bound result.\n        \"\"\"\n        ...\n\n    @required\n    async def and_then_await(self, function: AsyncUnary[T, Result[U, E]]) -&gt; Result[U, E]:\n        \"\"\"Returns the result if it is an [`Error[E]`][wraps_core.result.Error],\n        otherwise calls the asynchronous `function` with the wrapped value and returns the result.\n\n        Example:\n            ```python\n            class InverseError(Enum):\n                DIVISION_BY_ZERO = \"division by zero\"\n\n            async def inverse(value: float) -&gt; Result[float, InverseError]:\n                return Ok(1.0 / value) if value else Error(InverseError.DIVISION_BY_ZERO)\n\n            two = Ok(2.0)\n            print((await two.and_then_await(inverse)).unwrap())  # 0.5\n\n            zero = Ok(0.0)\n            print((await zero.and_then_await(inverse)).unwrap_error())  # division by zero\n\n            error = Error(1.0)\n            print((await error.and_then_await(inverse)).unwrap_error())  # 1.0\n            ```\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The bound result.\n        \"\"\"\n        ...\n\n    @required\n    def or_else(self, function: Unary[E, Result[T, F]]) -&gt; Result[T, F]:\n        \"\"\"Returns the result if it is [`Ok[T]`][wraps_core.result.Ok], otherwise calls the `function`\n        with the wrapped error value and returns the result.\n\n        Example:\n            ```python\n            class NonZeroError(Enum):\n                ZERO = \"the value is zero\"\n\n            def check_non_zero(value: int) -&gt; Result[int, NonZeroError]:\n                return Ok(value) if value else Error(NonZeroError.ZERO)\n\n            five = Error(5)\n            print(error.or_else(check_non_zero).unwrap())  # 13\n\n            zero = Error(0)\n            print(zero.or_else(check_non_zero).unwrap_error())  # the value is zero\n\n            one = Ok(1)\n            print(one.or_else(check_non_zero).unwrap())  # 1\n            ```\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The bound result.\n        \"\"\"\n        ...\n\n    @required\n    async def or_else_await(self, function: AsyncUnary[E, Result[T, F]]) -&gt; Result[T, F]:\n        \"\"\"Returns the result if it is [`Ok[T]`][wraps_core.result.Ok], otherwise calls the asynchronous\n        `function` with the wrapped error value and returns the result.\n\n        Example:\n            ```python\n            class NonZeroError(Enum):\n                ZERO = \"the value is zero\"\n\n            async def check_non_zero(value: int) -&gt; Result[int, NonZeroError]:\n                return Ok(value) if value else Error(NonZeroError.ZERO)\n\n            five = Error(5)\n\n            print((await error.or_else_await(check_non_zero)).unwrap())  # 13\n\n            zero = Error(0)\n            print((await zero.or_else_await(check_non_zero)).unwrap_error())  # the value is zero\n\n            one = Ok(1)\n            print((await ok.or_else_await(check_non_zero)).unwrap())  # 1\n            ```\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The bound result.\n        \"\"\"\n        ...\n\n    def try_flatten(self: ResultProtocol[ResultProtocol[T, E], E]) -&gt; Result[T, E]:\n        \"\"\"Flattens a [`Result[Result[T, E], E]`][wraps_core.result.Result]\n        into a [`Result[T, E]`][wraps_core.result.Result].\n\n        This is equivalent to [`result.and_then(identity)`][wraps_core.result.ResultProtocol.and_then].\n\n        Example:\n            ```python\n            ok = Ok(42)\n            ok_nested = Ok(ok)\n            assert ok_nested.try_flatten() == ok\n\n            error = Error(13)\n            error_nested = Ok(error)\n            assert error_nested.try_flatten() == error\n\n            assert error.try_flatten() == error\n            ```\n\n        Returns:\n            The flattened result.\n        \"\"\"\n        return self.and_then(identity)  # type: ignore[arg-type]\n\n    def try_flatten_error(self: ResultProtocol[T, ResultProtocol[T, E]]) -&gt; Result[T, E]:\n        \"\"\"Flattens a [`Result[T, Result[T, E]]`][wraps_core.result.Result]\n        into a [`Result[T, E]`][wraps_core.result.Result].\n\n        This is equivalent to [`result.or_else(identity)`][wraps_core.result.ResultProtocol.or_else].\n\n        Example:\n            ```python\n            ok = Ok(42)\n            ok_nested = Error(ok)\n            assert ok_nested.try_flatten_error() == error\n\n            error = Error(13)\n            error_nested = Error(error)\n            assert error_nested.try_flatten_error() == error\n\n            assert ok.try_flatten_error() == ok\n            ```\n\n        Returns:\n            The flattened result.\n        \"\"\"\n        return self.or_else(identity)  # type: ignore[arg-type]\n\n    @required\n    def contains(self, value: U) -&gt; bool:\n        \"\"\"Checks if the contained value is equal to the `value`.\n\n        Example:\n            ```python\n            value = 42\n            other = 69\n\n            ok = Ok(value)\n            assert ok.contains(value)\n            assert not ok.contains(other)\n\n            error = Error(value)\n            assert not error.contains(value)\n            ```\n\n        Arguments:\n            value: The value to check against.\n\n        Returns:\n            Whether the contained value is equal to the `value`.\n        \"\"\"\n        ...\n\n    @required\n    def contains_error(self, error: F) -&gt; bool:\n        \"\"\"Checks if the contained error value is equal to the `error`.\n\n        Example:\n            ```python\n            value = 42\n            other = 69\n\n            error = Error(value)\n            assert error.contains_error(value)\n            assert not error.contains_error(other)\n\n            ok = Ok(value)\n            assert not ok.contains_error(value)\n            ```\n\n        Arguments:\n            error: The error value to check against.\n\n        Returns:\n            Whether the contained error value is equal to the `error`.\n        \"\"\"\n        ...\n\n    @required\n    def flip(self) -&gt; Result[E, T]:\n        \"\"\"Converts a [`Result[T, E]`][wraps_core.result.Result]\n        into a [`Result[E, T]`][wraps_core.result.Result].\n\n        [`Ok(value)`][wraps_core.result.Ok] and [`Error(error)`][wraps_core.result.Error] get swapped to\n        [`Error(value)`][wraps_core.result.Error] and [`Ok(error)`][wraps_core.result.Ok] respectively.\n\n        Example:\n            ```python\n            value = 42\n\n            result = Ok(value)\n            flipped = Error(value)\n\n            assert result.flip() == flipped\n            ```\n\n        Returns:\n            The flipped result.\n        \"\"\"\n        ...\n\n    @required\n    def into_ok_or_error(self: ResultProtocol[V, V]) -&gt; V:\n        \"\"\"Returns the value contained within [`Result[V, V]`][wraps_core.result.Result], regardless\n        of whether or not that result is [`Ok[V]`][wraps_core.result.Ok]\n        or [`Error[V]`][wraps_core.result.Error].\n\n        Example:\n            ```python\n            result: Result[int, int] = Ok(69)\n\n            print(result.into_ok_or_error())  # 69; inferred `int`\n\n            result = Error(42)\n\n            print(result.into_ok_or_error())  # 42; inferred `int`\n            ```\n\n        Returns:\n            The contained value, regardless of whether or not it is an error one.\n        \"\"\"\n        ...\n\n    @required\n    def into_either(self) -&gt; Either[T, E]:\n        \"\"\"Converts a [`Result[T, E]`][wraps_core.result.Result]\n        into an [`Either[T, E]`][wraps_core.either.Either].\n\n        [`Ok(value)`][wraps_core.result.Ok] is mapped to [`Left(value)`][wraps_core.either.Left]\n        and [`Error(error)`][wraps_core.result.Error] is mapped to [`Right(error)`][wraps_core.either.Right].\n\n        Example:\n            ```python\n            value = 42\n\n            ok = Ok(value)\n            left = Left(value)\n\n            assert ok.into_either() == left\n\n            error = Error(value)\n            right = Right(value)\n\n            assert error.into_either() == right\n            ```\n\n        Returns:\n            The mapped either.\n        \"\"\"\n        ...\n\n    @required\n    def early(self) -&gt; T:\n        \"\"\"Functionally similar to the *question-mark* (`?`) operator in Rust.\n\n        Calls to this method are to be combined with\n        [`@early_result`][wraps_core.early.decorators.early_result] decorators to work properly.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.is_ok","title":"<code>is_ok() -&gt; bool</code>","text":"<p>Checks if the result is <code>Ok[T]</code>.</p> Example <pre><code>ok = Ok(42)\nassert ok.is_ok()\n\nerror = Error(13)\nassert not error.is_ok()\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the result is <code>Ok[T]</code>.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef is_ok(self) -&gt; bool:\n    \"\"\"Checks if the result is [`Ok[T]`][wraps_core.result.Ok].\n\n    Example:\n        ```python\n        ok = Ok(42)\n        assert ok.is_ok()\n\n        error = Error(13)\n        assert not error.is_ok()\n        ```\n\n    Returns:\n        Whether the result is [`Ok[T]`][wraps_core.result.Ok].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.is_ok_and","title":"<code>is_ok_and(predicate: Predicate[T]) -&gt; bool</code>","text":"<p>Checks if the result is <code>Ok[T]</code> and the value inside of it matches the <code>predicate</code>.</p> Example <pre><code>def is_positive(value: int) -&gt; bool:\n    return value &gt; 0\n\nok = Ok(13)\nassert ok.is_ok_and(is_positive)\n\nzero = Ok(0)\nassert not zero.is_ok_and(is_positive)\n\nerror = Error(7)\nassert not error.is_ok_and(is_positive)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Predicate[T]</code> <p>The predicate to check the contained value against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the result is <code>Ok[T]</code> and the predicate is matched.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef is_ok_and(self, predicate: Predicate[T]) -&gt; bool:\n    \"\"\"Checks if the result is [`Ok[T]`][wraps_core.result.Ok] and the value\n    inside of it matches the `predicate`.\n\n    Example:\n        ```python\n        def is_positive(value: int) -&gt; bool:\n            return value &gt; 0\n\n        ok = Ok(13)\n        assert ok.is_ok_and(is_positive)\n\n        zero = Ok(0)\n        assert not zero.is_ok_and(is_positive)\n\n        error = Error(7)\n        assert not error.is_ok_and(is_positive)\n        ```\n\n    Arguments:\n        predicate: The predicate to check the contained value against.\n\n    Returns:\n        Whether the result is [`Ok[T]`][wraps_core.result.Ok] and the predicate is matched.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.is_ok_and_await","title":"<code>is_ok_and_await(predicate: AsyncPredicate[T]) -&gt; bool</code>  <code>async</code>","text":"<p>Checks if the result is <code>Ok[T]</code> and the value inside of it matches the asynchronous <code>predicate</code>.</p> Example <pre><code>async def is_positive(value: int) -&gt; bool:\n    return value &gt; 0\n\nok = Ok(13)\nassert await ok.is_ok_and_await(is_positive)\n\nzero = Ok(0)\nassert not await zero.is_ok_and_await(is_positive)\n\nerror = Error(7)\nassert not await error.is_ok_and_await(is_positive)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>AsyncPredicate[T]</code> <p>The asynchronous predicate to check the contained value against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the result is <code>Ok[T]</code> and</p> <code>bool</code> <p>the asynchronous predicate is matched.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def is_ok_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n    \"\"\"Checks if the result is [`Ok[T]`][wraps_core.result.Ok] and the value\n    inside of it matches the asynchronous `predicate`.\n\n    Example:\n        ```python\n        async def is_positive(value: int) -&gt; bool:\n            return value &gt; 0\n\n        ok = Ok(13)\n        assert await ok.is_ok_and_await(is_positive)\n\n        zero = Ok(0)\n        assert not await zero.is_ok_and_await(is_positive)\n\n        error = Error(7)\n        assert not await error.is_ok_and_await(is_positive)\n        ```\n\n    Arguments:\n        predicate: The asynchronous predicate to check the contained value against.\n\n    Returns:\n        Whether the result is [`Ok[T]`][wraps_core.result.Ok] and\n        the asynchronous predicate is matched.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.is_error","title":"<code>is_error() -&gt; bool</code>","text":"<p>Checks if the result is <code>Error[E]</code>.</p> Example <pre><code>error = Error(34)\nassert error.is_error()\n\nok = Ok(69)\nassert not ok.is_error()\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the result is <code>Error[E]</code>.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef is_error(self) -&gt; bool:\n    \"\"\"Checks if the result is [`Error[E]`][wraps_core.result.Error].\n\n    Example:\n        ```python\n        error = Error(34)\n        assert error.is_error()\n\n        ok = Ok(69)\n        assert not ok.is_error()\n        ```\n\n    Returns:\n        Whether the result is [`Error[E]`][wraps_core.result.Error].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.is_error_and","title":"<code>is_error_and(predicate: Predicate[E]) -&gt; bool</code>","text":"<p>Checks if the result is <code>Error[E]</code> and the value inside of it matches the <code>predicate</code>.</p> Example <pre><code>def is_negative(value: int) -&gt; bool:\n    return value &lt; 0\n\nerror = Error(-13)\nassert error.is_error_and(is_positive)\n\nzero = Error(0)\nassert not zero.is_error_and(is_positive)\n\nok = Ok(7)\nassert not ok.is_error_and(is_positive)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Predicate[E]</code> <p>The predicate to check the contained value against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the result is <code>Error[E]</code> and the predicate is matched.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef is_error_and(self, predicate: Predicate[E]) -&gt; bool:\n    \"\"\"Checks if the result is [`Error[E]`][wraps_core.result.Error] and the value\n    inside of it matches the `predicate`.\n\n    Example:\n        ```python\n        def is_negative(value: int) -&gt; bool:\n            return value &lt; 0\n\n        error = Error(-13)\n        assert error.is_error_and(is_positive)\n\n        zero = Error(0)\n        assert not zero.is_error_and(is_positive)\n\n        ok = Ok(7)\n        assert not ok.is_error_and(is_positive)\n        ```\n\n    Arguments:\n        predicate: The predicate to check the contained value against.\n\n    Returns:\n        Whether the result is [`Error[E]`][wraps_core.result.Error] and the predicate is matched.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.is_error_and_await","title":"<code>is_error_and_await(predicate: AsyncPredicate[E]) -&gt; bool</code>  <code>async</code>","text":"<p>Checks if the result is <code>Error[E]</code> and the value inside of it matches the asynchronous <code>predicate</code>.</p> Example <pre><code>async def is_negative(value: int) -&gt; bool:\n    return value &lt; 0\n\nerror = Error(-13)\nassert await error.is_error_and_await(is_negative)\n\nzero = Error(0)\nassert not await zero.is_error_and_await(is_negative)\n\nok = Ok(7)\nassert not await ok.is_error_and_await(is_negative)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>AsyncPredicate[E]</code> <p>The asynchronous predicate to check the contained value against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the result is <code>Error[E]</code> and</p> <code>bool</code> <p>the asynchronous predicate is matched.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def is_error_and_await(self, predicate: AsyncPredicate[E]) -&gt; bool:\n    \"\"\"Checks if the result is [`Error[E]`][wraps_core.result.Error] and the value\n    inside of it matches the asynchronous `predicate`.\n\n    Example:\n        ```python\n        async def is_negative(value: int) -&gt; bool:\n            return value &lt; 0\n\n        error = Error(-13)\n        assert await error.is_error_and_await(is_negative)\n\n        zero = Error(0)\n        assert not await zero.is_error_and_await(is_negative)\n\n        ok = Ok(7)\n        assert not await ok.is_error_and_await(is_negative)\n        ```\n\n    Arguments:\n        predicate: The asynchronous predicate to check the contained value against.\n\n    Returns:\n        Whether the result is [`Error[E]`][wraps_core.result.Error] and\n        the asynchronous predicate is matched.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.expect","title":"<code>expect(message: str) -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value.</p> Example <pre><code>&gt;&gt;&gt; ok = Ok(42)\n&gt;&gt;&gt; ok.expect(\"error!\")\n42\n&gt;&gt;&gt; error = Error(0)\n&gt;&gt;&gt; error.expect(\"error!\")\nTraceback (most recent call last):\n  ...\nwraps_core.panics.Panic: error!\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message used in panicking.</p> required <p>Raises:</p> Type Description <code>Panic</code> <p>Panics with the <code>message</code> if the result is <code>Error[E]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef expect(self, message: str) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ok = Ok(42)\n        &gt;&gt;&gt; ok.expect(\"error!\")\n        42\n        &gt;&gt;&gt; error = Error(0)\n        &gt;&gt;&gt; error.expect(\"error!\")\n        Traceback (most recent call last):\n          ...\n        wraps_core.panics.Panic: error!\n        ```\n\n    Arguments:\n        message: The message used in panicking.\n\n    Raises:\n        Panic: Panics with the `message` if the result is [`Error[E]`][wraps_core.result.Error].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.expect_error","title":"<code>expect_error(message: str) -&gt; E</code>","text":"<p>Returns the contained <code>Error[E]</code> value.</p> Example <pre><code>&gt;&gt;&gt; ok = Ok(42)\n&gt;&gt;&gt; ok.expect_error(\"ok!\")\nTraceback (most recent call last):\n  ...\nwraps_core.panics.Panic: ok!\n\n&gt;&gt;&gt; error = Error(0)\n&gt;&gt;&gt; error.expect_error(\"ok!\")\n0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message used in panicking.</p> required <p>Raises:</p> Type Description <code>Panic</code> <p>Panics with the <code>message</code> if the result is <code>Ok[T]</code>.</p> <p>Returns:</p> Type Description <code>E</code> <p>The contained value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef expect_error(self, message: str) -&gt; E:\n    \"\"\"Returns the contained [`Error[E]`][wraps_core.result.Error] value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ok = Ok(42)\n        &gt;&gt;&gt; ok.expect_error(\"ok!\")\n        Traceback (most recent call last):\n          ...\n        wraps_core.panics.Panic: ok!\n\n        &gt;&gt;&gt; error = Error(0)\n        &gt;&gt;&gt; error.expect_error(\"ok!\")\n        0\n        ```\n\n    Arguments:\n        message: The message used in panicking.\n\n    Raises:\n        Panic: Panics with the `message` if the result is [`Ok[T]`][wraps_core.result.Ok].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.unwrap","title":"<code>unwrap() -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value (of type <code>T</code>).</p> <p>Because this function may panic, its use is generally discouraged.</p> <p>Instead, prefer to use pattern matching and handle the <code>Error[E]</code> case explicitly, or call <code>unwrap_or</code> or <code>unwrap_or_else</code>.</p> Example <pre><code>&gt;&gt;&gt; ok = Ok(13)\n&gt;&gt;&gt; ok.unwrap()\n13\n\n&gt;&gt;&gt; error = Error(0)\n&gt;&gt;&gt; error.unwrap()\nTraceback (most recent call last):\n  ...\nwraps_core.panics.Panic: called `unwrap` on error\n</code></pre> <p>Raises:</p> Type Description <code>Panic</code> <p>Panics if the result is <code>Error[E]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef unwrap(self) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value (of type `T`).\n\n    Because this function may panic, its use is generally discouraged.\n\n    Instead, prefer to use pattern matching and handle the [`Error[E]`][wraps_core.result.Error]\n    case explicitly, or call [`unwrap_or`][wraps_core.result.ResultProtocol.unwrap_or]\n    or [`unwrap_or_else`][wraps_core.result.ResultProtocol.unwrap_or_else].\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ok = Ok(13)\n        &gt;&gt;&gt; ok.unwrap()\n        13\n\n        &gt;&gt;&gt; error = Error(0)\n        &gt;&gt;&gt; error.unwrap()\n        Traceback (most recent call last):\n          ...\n        wraps_core.panics.Panic: called `unwrap` on error\n        ```\n\n    Raises:\n        Panic: Panics if the result is [`Error[E]`][wraps_core.result.Error].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.unwrap_or","title":"<code>unwrap_or(default: T) -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or the provided <code>default</code>.</p> Example <pre><code>ok = Ok(69)\nassert ok.unwrap_or(0)\n\nerror = Error(13)\nassert not error.unwrap_or(0)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>T</code> <p>The default value to use.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The contained value or the <code>default</code> one.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef unwrap_or(self, default: T) -&gt; T:  # type: ignore[misc]\n    \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value or the provided `default`.\n\n    Example:\n        ```python\n        ok = Ok(69)\n        assert ok.unwrap_or(0)\n\n        error = Error(13)\n        assert not error.unwrap_or(0)\n        ```\n\n    Arguments:\n        default: The default value to use.\n\n    Returns:\n        The contained value or the `default` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.unwrap_or_else","title":"<code>unwrap_or_else(default: Nullary[T]) -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or computes it from the <code>default</code> function.</p> Example <pre><code>ok = Ok(5)\nassert ok.unwrap_or_else(int)\n\nerror = Error(8)\nassert not error.unwrap_or_else(int)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[T]</code> <p>The default-computing function to use.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The contained value or the <code>default()</code> one.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef unwrap_or_else(self, default: Nullary[T]) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value\n    or computes it from the `default` function.\n\n    Example:\n        ```python\n        ok = Ok(5)\n        assert ok.unwrap_or_else(int)\n\n        error = Error(8)\n        assert not error.unwrap_or_else(int)\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n\n    Returns:\n        The contained value or the `default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.unwrap_or_else_await","title":"<code>unwrap_or_else_await(default: AsyncNullary[T]) -&gt; T</code>  <code>async</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or computes it from the asynchronous <code>default</code> function.</p> Example <pre><code>async def default() -&gt; int:\n    return 0\n\nok = Ok(5)\nassert await ok.unwrap_or_else_await(default)\n\nerror = Error(8)\nassert not await error.unwrap_or_else_await(default)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[T]</code> <p>The asynchronous default-computing function to use.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The contained value or the <code>await default()</code> one.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value\n    or computes it from the asynchronous `default` function.\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 0\n\n        ok = Ok(5)\n        assert await ok.unwrap_or_else_await(default)\n\n        error = Error(8)\n        assert not await error.unwrap_or_else_await(default)\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n\n    Returns:\n        The contained value or the `await default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.or_raise","title":"<code>or_raise(error: AnyError) -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or raises the <code>error</code> provided.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AnyError</code> <p>The error to raise if the result is <code>Error[E]</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error provided, if the result is <code>Error[E]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef or_raise(self, error: AnyError) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value\n    or raises the `error` provided.\n\n    Arguments:\n        error: The error to raise if the result is [`Error[E]`][wraps_core.result.Error].\n\n    Raises:\n        AnyError: The error provided, if the result is [`Error[E]`][wraps_core.result.Error].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.or_raise_with","title":"<code>or_raise_with(error: Nullary[AnyError]) -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or raises the error computed from <code>error</code>.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Nullary[AnyError]</code> <p>The error to raise if the result is <code>Error[E]</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error computed, if the result is <code>Error[E]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value\n    or raises the error computed from `error`.\n\n    Arguments:\n        error: The error to raise if the result is [`Error[E]`][wraps_core.result.Error].\n\n    Raises:\n        AnyError: The error computed, if the result is\n            [`Error[E]`][wraps_core.result.Error].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.or_raise_with_await","title":"<code>or_raise_with_await(error: AsyncNullary[AnyError]) -&gt; T</code>  <code>async</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or raises the error computed asynchronously from <code>error</code>.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AsyncNullary[AnyError]</code> <p>The error to raise if the result is <code>Error[E]</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error computed, if the result is <code>Error[E]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value\n    or raises the error computed asynchronously from `error`.\n\n    Arguments:\n        error: The error to raise if the result is [`Error[E]`][wraps_core.result.Error].\n\n    Raises:\n        AnyError: The error computed, if the result is\n            [`Error[E]`][wraps_core.result.Error].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.unwrap_error","title":"<code>unwrap_error() -&gt; E</code>","text":"<p>Returns the contained <code>Error[E]</code> value.</p> <p>Because this function may panic, its use is generally discouraged.</p> <p>Instead, prefer to use pattern matching and handle the <code>Ok[T]</code> case explicitly, or call <code>unwrap_error_or</code> or <code>unwrap_error_or_else</code>.</p> Example <pre><code>&gt;&gt;&gt; error = Error(13)\n&gt;&gt;&gt; error.unwrap_error()\n13\n\n&gt;&gt;&gt; ok = Ok(42)\n&gt;&gt;&gt; ok.unwrap_error()\nTraceback (most recent call last):\n  ...\nwraps_core.panics.Panic: called `unwrap_error` on ok\n</code></pre> <p>Raises:</p> Type Description <code>Panic</code> <p>Panics if the result is <code>Ok[T]</code>.</p> <p>Returns:</p> Type Description <code>E</code> <p>The contained error value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef unwrap_error(self) -&gt; E:\n    \"\"\"Returns the contained [`Error[E]`][wraps_core.result.Error] value.\n\n    Because this function may panic, its use is generally discouraged.\n\n    Instead, prefer to use pattern matching and handle the [`Ok[T]`][wraps_core.result.Ok]\n    case explicitly, or call [`unwrap_error_or`][wraps_core.result.ResultProtocol.unwrap_error_or]\n    or [`unwrap_error_or_else`][wraps_core.result.ResultProtocol.unwrap_error_or_else].\n\n    Example:\n        ```python\n        &gt;&gt;&gt; error = Error(13)\n        &gt;&gt;&gt; error.unwrap_error()\n        13\n\n        &gt;&gt;&gt; ok = Ok(42)\n        &gt;&gt;&gt; ok.unwrap_error()\n        Traceback (most recent call last):\n          ...\n        wraps_core.panics.Panic: called `unwrap_error` on ok\n        ```\n\n    Raises:\n        Panic: Panics if the result is [`Ok[T]`][wraps_core.result.Ok].\n\n    Returns:\n        The contained error value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.unwrap_error_or","title":"<code>unwrap_error_or(default: E) -&gt; E</code>","text":"<p>Returns the contained <code>Error[E]</code> value (of type <code>E</code>) or a provided default.</p> Example <pre><code>error = Error(1)\nassert error.unwrap_error_or(0)\n\nok = Ok(2)\nassert not ok.unwrap_error_or(0)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>E</code> <p>The default value to use.</p> required <p>Returns:</p> Type Description <code>E</code> <p>The contained error value or the <code>default</code> one.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef unwrap_error_or(self, default: E) -&gt; E:  # type: ignore[misc]\n    \"\"\"Returns the contained [`Error[E]`][wraps_core.result.Error] value (of type `E`)\n    or a provided default.\n\n    Example:\n        ```python\n        error = Error(1)\n        assert error.unwrap_error_or(0)\n\n        ok = Ok(2)\n        assert not ok.unwrap_error_or(0)\n        ```\n\n    Arguments:\n        default: The default value to use.\n\n    Returns:\n        The contained error value or the `default` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.unwrap_error_or_else","title":"<code>unwrap_error_or_else(default: Nullary[E]) -&gt; E</code>","text":"<p>Returns the contained <code>Error[E]</code> value or computes it from the <code>default</code> function.</p> Example <p>```python error = Error(5) assert error.unwrap_error_or_else(int)</p> <p>ok = Ok(8) assert not ok.unwrap_error_or_else(int)</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[E]</code> <p>The default-computing function to use.</p> required <p>Returns:</p> Type Description <code>E</code> <p>The contained error value or the <code>default()</code> one.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef unwrap_error_or_else(self, default: Nullary[E]) -&gt; E:\n    \"\"\"Returns the contained [`Error[E]`][wraps_core.result.Error] value\n    or computes it from the `default` function.\n\n    Example:\n        ```python\n        error = Error(5)\n        assert error.unwrap_error_or_else(int)\n\n        ok = Ok(8)\n        assert not ok.unwrap_error_or_else(int)\n\n    Arguments:\n        default: The default-computing function to use.\n\n    Returns:\n        The contained error value or the `default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.unwrap_error_or_else_await","title":"<code>unwrap_error_or_else_await(default: AsyncNullary[E]) -&gt; E</code>  <code>async</code>","text":"<p>Returns the contained <code>Error[E]</code> value or computes it from the asynchronous <code>default</code> function.</p> Example <pre><code>async def default() -&gt; int:\n    return 0\n\nerror = Error(13)\nassert await error.unwrap_error_or_else_await(default)\n\nok = Ok(5)\nassert not await ok.unwrap_error_or_else_await(default)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[E]</code> <p>The asynchronous default-computing function to use.</p> required <p>Returns:</p> Type Description <code>E</code> <p>The contained error value or the <code>await default()</code> one.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def unwrap_error_or_else_await(self, default: AsyncNullary[E]) -&gt; E:\n    \"\"\"Returns the contained [`Error[E]`][wraps_core.result.Error] value\n    or computes it from the asynchronous `default` function.\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 0\n\n        error = Error(13)\n        assert await error.unwrap_error_or_else_await(default)\n\n        ok = Ok(5)\n        assert not await ok.unwrap_error_or_else_await(default)\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n\n    Returns:\n        The contained error value or the `await default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.raising","title":"<code>raising() -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or raises the contained <code>Error[AnyError]</code> value.</p> Example <pre><code>&gt;&gt;&gt; ok = Ok(13)\n&gt;&gt;&gt; ok.raising()\n13\n\n&gt;&gt;&gt; error = Error(ValueError(\"error...\"))\n&gt;&gt;&gt; error.raising()\nTraceback (most recent call last):\n  ...\nValueError: error...\n</code></pre> <p>Raises:</p> Type Description <code>AnyError</code> <p>The contained error, if the result is <code>Error[AnyError]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef raising(self: ResultProtocol[T, AnyError]) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps_core.result.Ok] value or raises the\n    contained [`Error[AnyError]`][wraps_core.result.Error] value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ok = Ok(13)\n        &gt;&gt;&gt; ok.raising()\n        13\n\n        &gt;&gt;&gt; error = Error(ValueError(\"error...\"))\n        &gt;&gt;&gt; error.raising()\n        Traceback (most recent call last):\n          ...\n        ValueError: error...\n        ```\n\n    Raises:\n        AnyError: The contained error, if the result is [`Error[AnyError]`][wraps_core.result.Error].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.ok","title":"<code>ok() -&gt; Option[T]</code>","text":"<p>Converts a <code>Result[T, E]</code> into an <code>Option[T]</code>.</p> <p>Converts <code>self</code> into an <code>Option[T]</code>, discarding errors, if any.</p> Example <pre><code>ok = Ok(42)\n\nassert ok.ok().is_some()\n\nerror = Error(0)\n\nassert error.ok().is_null()\n</code></pre> <p>Returns:</p> Type Description <code>Option[T]</code> <p>The converted option.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef ok(self) -&gt; Option[T]:\n    \"\"\"Converts a [`Result[T, E]`][wraps_core.result.Result]\n    into an [`Option[T]`][wraps_core.option.Option].\n\n    Converts `self` into an [`Option[T]`][wraps_core.option.Option], discarding errors, if any.\n\n    Example:\n        ```python\n        ok = Ok(42)\n\n        assert ok.ok().is_some()\n\n        error = Error(0)\n\n        assert error.ok().is_null()\n        ```\n\n    Returns:\n        The converted option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.error","title":"<code>error() -&gt; Option[E]</code>","text":"<p>Converts a <code>Result[T, E]</code> into an <code>Option[E]</code>.</p> <p>Converts <code>self</code> into an <code>Option[E]</code>, discarding success values, if any.</p> Example <pre><code>error = Error(13)\n\nassert error.error().is_some()\n\nok = Ok(2)\n\nassert ok.error().is_null()\n</code></pre> <p>Returns:</p> Type Description <code>Option[E]</code> <p>The converted option.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef error(self) -&gt; Option[E]:\n    \"\"\"Converts a [`Result[T, E]`][wraps_core.result.Result]\n    into an [`Option[E]`][wraps_core.option.Option].\n\n    Converts `self` into an [`Option[E]`][wraps_core.option.Option],\n    discarding success values, if any.\n\n    Example:\n        ```python\n        error = Error(13)\n\n        assert error.error().is_some()\n\n        ok = Ok(2)\n\n        assert ok.error().is_null()\n        ```\n\n    Returns:\n        The converted option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.inspect","title":"<code>inspect(function: Inspect[T]) -&gt; Result[T, E]</code>","text":"<p>Inspects a possibly contained <code>Ok[T]</code> value.</p> Example <pre><code>ok = Ok(\"Hello, world!\")\n\nsame = ok.inspect(print)  # Hello, world!\n\nassert ok == same\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Inspect[T]</code> <p>The inspecting function.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The inspected result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef inspect(self, function: Inspect[T]) -&gt; Result[T, E]:\n    \"\"\"Inspects a possibly contained [`Ok[T]`][wraps_core.result.Ok] value.\n\n    Example:\n        ```python\n        ok = Ok(\"Hello, world!\")\n\n        same = ok.inspect(print)  # Hello, world!\n\n        assert ok == same\n        ```\n\n    Arguments:\n        function: The inspecting function.\n\n    Returns:\n        The inspected result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.inspect_await","title":"<code>inspect_await(function: AsyncInspect[T]) -&gt; Result[T, E]</code>  <code>async</code>","text":"<p>Inspects a possibly contained <code>Ok[T]</code> value.</p> Example <pre><code>async def function(value: str) -&gt; None:\n    print(value)\n\nok = Ok(\"Hello, world!\")\n\nsame = await ok.inspect_await(function)  # Hello, world!\n\nassert ok == same\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncInspect[T]</code> <p>The asynchronous inspecting function.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The inspected result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def inspect_await(self, function: AsyncInspect[T]) -&gt; Result[T, E]:\n    \"\"\"Inspects a possibly contained [`Ok[T]`][wraps_core.result.Ok] value.\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; None:\n            print(value)\n\n        ok = Ok(\"Hello, world!\")\n\n        same = await ok.inspect_await(function)  # Hello, world!\n\n        assert ok == same\n        ```\n\n    Arguments:\n        function: The asynchronous inspecting function.\n\n    Returns:\n        The inspected result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.inspect_error","title":"<code>inspect_error(function: Inspect[E]) -&gt; Result[T, E]</code>","text":"<p>Inspects a possibly contained <code>Error[E]</code> value.</p> Example <pre><code>error = Error(\"Bye, world!\")\n\nsame = error.inspect_error(print)  # Bye, world!\n\nassert error == same\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Inspect[E]</code> <p>The error-inspecting function.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The inspected result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef inspect_error(self, function: Inspect[E]) -&gt; Result[T, E]:\n    \"\"\"Inspects a possibly contained [`Error[E]`][wraps_core.result.Error] value.\n\n    Example:\n        ```python\n        error = Error(\"Bye, world!\")\n\n        same = error.inspect_error(print)  # Bye, world!\n\n        assert error == same\n        ```\n\n    Arguments:\n        function: The error-inspecting function.\n\n    Returns:\n        The inspected result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.inspect_error_await","title":"<code>inspect_error_await(function: AsyncInspect[E]) -&gt; Result[T, E]</code>  <code>async</code>","text":"<p>Inspects a possibly contained <code>Error[E]</code> value.</p> Example <pre><code>async def function(value: str) -&gt; None:\n    print(value)\n\nerror = Error(\"Bye, world!\")\n\nsame = await error.inspect_error_await(function)  # Bye, world!\n\nassert error == same\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncInspect[E]</code> <p>The asynchronous error-inspecting function.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The inspected result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def inspect_error_await(self, function: AsyncInspect[E]) -&gt; Result[T, E]:\n    \"\"\"Inspects a possibly contained [`Error[E]`][wraps_core.result.Error] value.\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; None:\n            print(value)\n\n        error = Error(\"Bye, world!\")\n\n        same = await error.inspect_error_await(function)  # Bye, world!\n\n        assert error == same\n        ```\n\n    Arguments:\n        function: The asynchronous error-inspecting function.\n\n    Returns:\n        The inspected result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map","title":"<code>map(function: Unary[T, U]) -&gt; Result[U, E]</code>","text":"<p>Maps a <code>Result[T, E]</code> to a <code>Result[U, E]</code> by applying <code>function</code> to the contained <code>Ok[T]</code> value, leaving any <code>Error[E]</code> values untouched.</p> <p>This function can be used to compose the results of two functions.</p> Example <pre><code>value = 69\nmapped = \"69\"\n\nok = Ok(value)\n\nassert ok.map(str) == Ok(mapped)\n\nerror = Error(0)\n\nassert error.map(str) == error\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Result[U, E]</code> <p>The mapped result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef map(self, function: Unary[T, U]) -&gt; Result[U, E]:\n    \"\"\"Maps a [`Result[T, E]`][wraps_core.result.Result] to a [`Result[U, E]`][wraps_core.result.Result]\n    by applying `function` to the contained [`Ok[T]`][wraps_core.result.Ok] value,\n    leaving any [`Error[E]`][wraps_core.result.Error] values untouched.\n\n    This function can be used to compose the results of two functions.\n\n    Example:\n        ```python\n        value = 69\n        mapped = \"69\"\n\n        ok = Ok(value)\n\n        assert ok.map(str) == Ok(mapped)\n\n        error = Error(0)\n\n        assert error.map(str) == error\n        ```\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The mapped result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_or","title":"<code>map_or(default: U, function: Unary[T, U]) -&gt; U</code>","text":"<p>Returns the default value (if errored), or applies the <code>function</code> to the contained value (if succeeded).</p> Example <pre><code>ok = Ok(\"Hello, world!\")\nprint(ok.map_or(42, len))  # 13\n\nerror = Error(\"error...\")\nprint(error.map_or(42, len))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>U</code> <p>The default value to use.</p> required <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting or the default value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n    \"\"\"Returns the default value (if errored), or applies the `function`\n    to the contained value (if succeeded).\n\n    Example:\n        ```python\n        ok = Ok(\"Hello, world!\")\n        print(ok.map_or(42, len))  # 13\n\n        error = Error(\"error...\")\n        print(error.map_or(42, len))  # 42\n        ```\n\n    Arguments:\n        default: The default value to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting or the default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_or_else","title":"<code>map_or_else(default: Nullary[U], function: Unary[T, U]) -&gt; U</code>","text":"<p>Computes the default value (if errored), or applies the <code>function</code> to the contained value (if succeeded).</p> Example <pre><code>ok = Ok(\"Hello, world!\")\nprint(ok.map_or_else(int, len))  # 13\n\nerror = Error(\"error!\")\nprint(error.map_or_else(int, len))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[U]</code> <p>The default-computing function to use.</p> required <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting or the default computed value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n    \"\"\"Computes the default value (if errored), or applies the `function`\n    to the contained value (if succeeded).\n\n    Example:\n        ```python\n        ok = Ok(\"Hello, world!\")\n        print(ok.map_or_else(int, len))  # 13\n\n        error = Error(\"error!\")\n        print(error.map_or_else(int, len))  # 0\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting or the default computed value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_or_else_await","title":"<code>map_or_else_await(default: AsyncNullary[U], function: Unary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Computes the default value (if errored), or applies the <code>function</code> to the contained value (if succeeded).</p> Example <pre><code>async def default() -&gt; int:\n    return 0\n\nok = Ok(\"Hello, world!\")\nprint(await ok.map_or_else_await(default, len))  # 13\n\nerror = Error(\"error!\")\nprint(await error.map_or_else_await(default, len))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[U]</code> <p>The asynchronous default-computing function to use.</p> required <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting or the default computed value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n    \"\"\"Computes the default value (if errored), or applies the `function`\n    to the contained value (if succeeded).\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 0\n\n        ok = Ok(\"Hello, world!\")\n        print(await ok.map_or_else_await(default, len))  # 13\n\n        error = Error(\"error!\")\n        print(await error.map_or_else_await(default, len))  # 0\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting or the default computed value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_error","title":"<code>map_error(function: Unary[E, F]) -&gt; Result[T, F]</code>","text":"<p>Maps a <code>Result[T, E]</code> to a <code>Result[T, F]</code> by applying the <code>function</code> to the contained <code>Error[E]</code> value, leaving any <code>Ok[T]</code> values untouched.</p> Example <pre><code>value = 42\nmapped = \"42\"\n\nerror = Error(value)\n\nassert error.map_error(str) == Error(mapped)\n\nok = Ok(2)\n\nassert ok.map_error(str) == ok\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[E, F]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Result[T, F]</code> <p>The mapped result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef map_error(self, function: Unary[E, F]) -&gt; Result[T, F]:\n    \"\"\"Maps a [`Result[T, E]`][wraps_core.result.Result] to a [`Result[T, F]`][wraps_core.result.Result]\n    by applying the `function` to the contained [`Error[E]`][wraps_core.result.Error] value,\n    leaving any [`Ok[T]`][wraps_core.result.Ok] values untouched.\n\n    Example:\n        ```python\n        value = 42\n        mapped = \"42\"\n\n        error = Error(value)\n\n        assert error.map_error(str) == Error(mapped)\n\n        ok = Ok(2)\n\n        assert ok.map_error(str) == ok\n        ```\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The mapped result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_error_or","title":"<code>map_error_or(default: F, function: Unary[E, F]) -&gt; F</code>","text":"<p>Returns the default value (if succeeded), or applies the <code>function</code> to the contained error value (if errored).</p> Example <pre><code>error = Error(\"nekit\")\nprint(error.map_error_or(13, len))  # 5\n\nok = Ok(\"ok\")\nprint(error.map_error_or(13, len))  # 13\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>F</code> <p>The default value to use.</p> required <code>function</code> <code>Unary[E, F]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The resulting or the default value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef map_error_or(self, default: F, function: Unary[E, F]) -&gt; F:\n    \"\"\"Returns the default value (if succeeded), or applies the `function`\n    to the contained error value (if errored).\n\n    Example:\n        ```python\n        error = Error(\"nekit\")\n        print(error.map_error_or(13, len))  # 5\n\n        ok = Ok(\"ok\")\n        print(error.map_error_or(13, len))  # 13\n        ```\n\n    Arguments:\n        default: The default value to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting or the default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_error_or_else","title":"<code>map_error_or_else(default: Nullary[F], function: Unary[E, F]) -&gt; F</code>","text":"<p>Computes the default value (if succeeded), or applies the <code>function</code> to the contained value (if errored).</p> Example <pre><code>error = Error(\"error...\")\nprint(error.map_error_or_else(int, len))  # 8\n\nok = Ok(\"ok!\")\nprint(ok.map_error_or_else(int, len))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[F]</code> <p>The default-computing function to use.</p> required <code>function</code> <code>Unary[E, F]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The resulting or the computed default value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef map_error_or_else(self, default: Nullary[F], function: Unary[E, F]) -&gt; F:\n    \"\"\"Computes the default value (if succeeded), or applies the `function`\n    to the contained value (if errored).\n\n    Example:\n        ```python\n        error = Error(\"error...\")\n        print(error.map_error_or_else(int, len))  # 8\n\n        ok = Ok(\"ok!\")\n        print(ok.map_error_or_else(int, len))  # 0\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting or the computed default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_error_or_else_await","title":"<code>map_error_or_else_await(default: AsyncNullary[F], function: Unary[E, F]) -&gt; F</code>  <code>async</code>","text":"<p>Computes the default value (if succeeded), or applies the <code>function</code> to the contained value (if errored).</p> Example <pre><code>error = Error(\"error...\")\nprint(await error.map_error_or_else(int, len))  # 8\n\nok = Ok(\"ok!\")\nprint(await ok.map_error_or_else(int, len))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[F]</code> <p>The asynchronous default-computing function to use.</p> required <code>function</code> <code>Unary[E, F]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The resulting or the computed default value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def map_error_or_else_await(self, default: AsyncNullary[F], function: Unary[E, F]) -&gt; F:\n    \"\"\"Computes the default value (if succeeded), or applies the `function`\n    to the contained value (if errored).\n\n    Example:\n        ```python\n        error = Error(\"error...\")\n        print(await error.map_error_or_else(int, len))  # 8\n\n        ok = Ok(\"ok!\")\n        print(await ok.map_error_or_else(int, len))  # 0\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting or the computed default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_await","title":"<code>map_await(function: AsyncUnary[T, U]) -&gt; Result[U, E]</code>  <code>async</code>","text":"<p>Maps a <code>Result[T, E]</code> to a <code>Result[U, E]</code> by applying the asynchronous <code>function</code> to the contained <code>Ok[T]</code> value, leaving any <code>Error[E]</code> values untouched.</p> <p>This function can be used to compose the results of two functions.</p> Example <pre><code>async def function(value: int) -&gt; str:\n    return str(value)\n\nvalue = 69\nmapped = \"69\"\n\nok = Ok(value)\n\nassert await ok.map_await(function) == Ok(mapped)\n\nerror = Error(0)\n\nassert await error.map_await(function) == error\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Result[U, E]</code> <p>The mapped result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def map_await(self, function: AsyncUnary[T, U]) -&gt; Result[U, E]:\n    \"\"\"Maps a [`Result[T, E]`][wraps_core.result.Result] to a [`Result[U, E]`][wraps_core.result.Result]\n    by applying the asynchronous `function` to the contained [`Ok[T]`][wraps_core.result.Ok] value,\n    leaving any [`Error[E]`][wraps_core.result.Error] values untouched.\n\n    This function can be used to compose the results of two functions.\n\n    Example:\n        ```python\n        async def function(value: int) -&gt; str:\n            return str(value)\n\n        value = 69\n        mapped = \"69\"\n\n        ok = Ok(value)\n\n        assert await ok.map_await(function) == Ok(mapped)\n\n        error = Error(0)\n\n        assert await error.map_await(function) == error\n        ```\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The mapped result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_await_or","title":"<code>map_await_or(default: U, function: AsyncUnary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Returns the default value (if errored), or applies the asynchronous <code>function</code> to the contained value (if succeeded).</p> Example <pre><code>async def function(value: str) -&gt; int:\n    return len(value)\n\nok = Ok(\"Hello, world!\")\nprint(await ok.map_await_or(42, function))  # 13\n\nerror = Error(\"error...\")\nprint(error.map_await_or(42, function))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>U</code> <p>The default value to use.</p> required <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting or the default value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n    \"\"\"Returns the default value (if errored), or applies the asynchronous `function`\n    to the contained value (if succeeded).\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        ok = Ok(\"Hello, world!\")\n        print(await ok.map_await_or(42, function))  # 13\n\n        error = Error(\"error...\")\n        print(error.map_await_or(42, function))  # 42\n        ```\n\n    Arguments:\n        default: The default value to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting or the default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_await_or_else","title":"<code>map_await_or_else(default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Computes the default value (if errored), or applies the asynchronous <code>function</code> to the contained value (if succeeded).</p> Example <pre><code>async def async_len(value: str) -&gt; int:\n    return len(value)\n\nok = Ok(\"Hello, world!\")\nprint(await ok.map_await_or_else(int, async_len))  # 13\n\nerror = Error(\"error!\")\nprint(await error.map_await_or_else(int, async_len))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[U]</code> <p>The default-computing function to use.</p> required <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting or the computed default value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n    \"\"\"Computes the default value (if errored), or applies the asynchronous `function`\n    to the contained value (if succeeded).\n\n    Example:\n        ```python\n        async def async_len(value: str) -&gt; int:\n            return len(value)\n\n        ok = Ok(\"Hello, world!\")\n        print(await ok.map_await_or_else(int, async_len))  # 13\n\n        error = Error(\"error!\")\n        print(await error.map_await_or_else(int, async_len))  # 0\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting or the computed default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_await_or_else_await","title":"<code>map_await_or_else_await(default: AsyncNullary[U], function: AsyncUnary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Computes the default value (if errored), or applies the asynchronous <code>function</code> to the contained value (if succeeded).</p> Example <pre><code>async def default() -&gt; int:\n    return 0\n\nasync def function(value: str) -&gt; int:\n    return len(value)\n\nok = Ok(\"Hello, world!\")\nprint(await ok.map_await_or_else_await(default, function))  # 13\n\nerror = Error(\"error!\")\nprint(await error.map_await_or_else_await(default, function))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[U]</code> <p>The asynchronous default-computing function to use.</p> required <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting or the computed default value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def map_await_or_else_await(\n    self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n) -&gt; U:\n    \"\"\"Computes the default value (if errored), or applies the asynchronous `function`\n    to the contained value (if succeeded).\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 0\n\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        ok = Ok(\"Hello, world!\")\n        print(await ok.map_await_or_else_await(default, function))  # 13\n\n        error = Error(\"error!\")\n        print(await error.map_await_or_else_await(default, function))  # 0\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting or the computed default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_error_await","title":"<code>map_error_await(function: AsyncUnary[E, F]) -&gt; Result[T, F]</code>  <code>async</code>","text":"<p>Maps a <code>Result[T, E]</code> to a <code>Result[T, F]</code> by applying the asynchronous <code>function</code> to the contained <code>Error[E]</code> value, leaving any <code>Ok[T]</code> values untouched.</p> Example <pre><code>async def function(value: int) -&gt; str:\n    return str(value)\n\nvalue = 42\nmapped = \"42\"\n\nerror = Error(value)\n\nassert await error.map_error_await(function) == Error(mapped)\n\nok = Ok(13)\n\nassert await ok.map_error_await(function) == ok\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[E, F]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Result[T, F]</code> <p>The mapped result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def map_error_await(self, function: AsyncUnary[E, F]) -&gt; Result[T, F]:\n    \"\"\"Maps a [`Result[T, E]`][wraps_core.result.Result] to a [`Result[T, F]`][wraps_core.result.Result]\n    by applying the asynchronous `function` to the contained [`Error[E]`][wraps_core.result.Error]\n    value, leaving any [`Ok[T]`][wraps_core.result.Ok] values untouched.\n\n    Example:\n        ```python\n        async def function(value: int) -&gt; str:\n            return str(value)\n\n        value = 42\n        mapped = \"42\"\n\n        error = Error(value)\n\n        assert await error.map_error_await(function) == Error(mapped)\n\n        ok = Ok(13)\n\n        assert await ok.map_error_await(function) == ok\n        ```\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The mapped result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_error_await_or","title":"<code>map_error_await_or(default: F, function: AsyncUnary[E, F]) -&gt; F</code>  <code>async</code>","text":"<p>Returns the default value (if succeeded), or applies the asynchronous <code>function</code> to the contained value (if errored).</p> Example <pre><code>async def function(value: str) -&gt; int:\n    return len(value)\n\nerror = Error(\"Bye, world!\")\nprint(await error.map_error_await_or(42, function))  # 11\n\nok = Ok(\"Hello, world!\")\nprint(await ok.map_error_await_or(42, function))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>F</code> <p>The default value to use.</p> required <code>function</code> <code>AsyncUnary[E, F]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The resulting or the default value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def map_error_await_or(self, default: F, function: AsyncUnary[E, F]) -&gt; F:\n    \"\"\"Returns the default value (if succeeded), or applies the asynchronous `function`\n    to the contained value (if errored).\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        error = Error(\"Bye, world!\")\n        print(await error.map_error_await_or(42, function))  # 11\n\n        ok = Ok(\"Hello, world!\")\n        print(await ok.map_error_await_or(42, function))  # 42\n        ```\n\n    Arguments:\n        default: The default value to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting or the default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_error_await_or_else","title":"<code>map_error_await_or_else(default: Nullary[F], function: AsyncUnary[E, F]) -&gt; F</code>  <code>async</code>","text":"<p>Computes the default value (if succeeded), or applies the asynchronous <code>function</code> to the contained value (if errored).</p> Example <pre><code>async def async_len(value: str) -&gt; int:\n    return len(value)\n\nerror = Error(\"Bye, world!\")\nprint(await error.map_error_await_or_else(int, async_len))  # 11\n\nok = Ok(\"Hello, world!\")\nprint(await ok.map_error_await_or_else(int, async_len))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[F]</code> <p>The default-computing function to use.</p> required <code>function</code> <code>AsyncUnary[E, F]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The resulting or the computed default value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def map_error_await_or_else(self, default: Nullary[F], function: AsyncUnary[E, F]) -&gt; F:\n    \"\"\"Computes the default value (if succeeded), or applies the asynchronous `function`\n    to the contained value (if errored).\n\n    Example:\n        ```python\n        async def async_len(value: str) -&gt; int:\n            return len(value)\n\n        error = Error(\"Bye, world!\")\n        print(await error.map_error_await_or_else(int, async_len))  # 11\n\n        ok = Ok(\"Hello, world!\")\n        print(await ok.map_error_await_or_else(int, async_len))  # 0\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting or the computed default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.map_error_await_or_else_await","title":"<code>map_error_await_or_else_await(default: AsyncNullary[F], function: AsyncUnary[E, F]) -&gt; F</code>  <code>async</code>","text":"<p>Computes the default value (if succeeded), or applies the asynchronous <code>function</code> to the contained value (if errored).</p> Example <pre><code>async def default() -&gt; int:\n    return 0\n\nasync def function(value: str) -&gt; int:\n    return len(value)\n\nerror = Error(\"error\")\nprint(await error.map_error_await_or_else_await(default, function))  # 5\n\nok = Ok(\"ok\")\nprint(await ok.map_error_await_or_else_await(default, function))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[F]</code> <p>The asynchronous default-computing function to use.</p> required <code>function</code> <code>AsyncUnary[E, F]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The resulting or the default computed value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def map_error_await_or_else_await(\n    self, default: AsyncNullary[F], function: AsyncUnary[E, F]\n) -&gt; F:\n    \"\"\"Computes the default value (if succeeded), or applies the asynchronous `function`\n    to the contained value (if errored).\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 0\n\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        error = Error(\"error\")\n        print(await error.map_error_await_or_else_await(default, function))  # 5\n\n        ok = Ok(\"ok\")\n        print(await ok.map_error_await_or_else_await(default, function))  # 0\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting or the default computed value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.iter","title":"<code>iter() -&gt; Iterator[T]</code>","text":"<p>Returns an iterator over the possibly contained value.</p> Example <pre><code>&gt;&gt;&gt; ok = Ok(42)\n&gt;&gt;&gt; next(ok.iter(), 0)\n42\n&gt;&gt;&gt; error = Error(13)\n&gt;&gt;&gt; next(error.iter(), 0)\n0\n</code></pre> <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>An iterator over the possibly contained value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef iter(self) -&gt; Iterator[T]:\n    \"\"\"Returns an iterator over the possibly contained value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ok = Ok(42)\n        &gt;&gt;&gt; next(ok.iter(), 0)\n        42\n        &gt;&gt;&gt; error = Error(13)\n        &gt;&gt;&gt; next(error.iter(), 0)\n        0\n        ```\n\n    Returns:\n        An iterator over the possibly contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.iter_error","title":"<code>iter_error() -&gt; Iterator[E]</code>","text":"<p>Returns an iterator over the possibly contained error value.</p> Example <pre><code>&gt;&gt;&gt; error = Error(13)\n&gt;&gt;&gt; next(error.iter_error(), 0)\n13\n&gt;&gt;&gt; ok = Ok(1)\n&gt;&gt;&gt; next(ok.iter_error(), 0)\n0\n</code></pre> <p>Returns:</p> Type Description <code>Iterator[E]</code> <p>An iterator over the possibly contained error value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef iter_error(self) -&gt; Iterator[E]:\n    \"\"\"Returns an iterator over the possibly contained error value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; error = Error(13)\n        &gt;&gt;&gt; next(error.iter_error(), 0)\n        13\n        &gt;&gt;&gt; ok = Ok(1)\n        &gt;&gt;&gt; next(ok.iter_error(), 0)\n        0\n        ```\n\n    Returns:\n        An iterator over the possibly contained error value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.async_iter","title":"<code>async_iter() -&gt; AsyncIterator[T]</code>","text":"<p>Returns an asynchronous iterator over the possibly contained <code>Ok[T]</code> value.</p> Example <pre><code>&gt;&gt;&gt; ok = Ok(42)\n&gt;&gt;&gt; await async_next(ok.async_iter(), 0)\n42\n&gt;&gt;&gt; error = Error(13)\n&gt;&gt;&gt; await async_next(error.async_iter(), 0)\n0\n</code></pre> <p>Returns:</p> Type Description <code>AsyncIterator[T]</code> <p>An asynchronous iterator over the possibly contained value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef async_iter(self) -&gt; AsyncIterator[T]:\n    \"\"\"Returns an asynchronous iterator over the possibly contained\n    [`Ok[T]`][wraps_core.result.Ok] value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ok = Ok(42)\n        &gt;&gt;&gt; await async_next(ok.async_iter(), 0)\n        42\n        &gt;&gt;&gt; error = Error(13)\n        &gt;&gt;&gt; await async_next(error.async_iter(), 0)\n        0\n        ```\n\n    Returns:\n        An asynchronous iterator over the possibly contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.async_iter_error","title":"<code>async_iter_error() -&gt; AsyncIterator[E]</code>","text":"<p>Returns an asynchronous iterator over the possibly contained <code>Error[E]</code> value.</p> Example <pre><code>&gt;&gt;&gt; error = Error(42)\n&gt;&gt;&gt; await async_next(error.async_iter_error(), 0)\n42\n&gt;&gt;&gt; ok = Ok(13)\n&gt;&gt;&gt; await async_next(ok.async_iter_error(), 0)\n0\n</code></pre> <p>Returns:</p> Type Description <code>AsyncIterator[E]</code> <p>An asynchronous iterator over the possibly contained error value.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef async_iter_error(self) -&gt; AsyncIterator[E]:\n    \"\"\"Returns an asynchronous iterator over the possibly contained\n    [`Error[E]`][wraps_core.result.Error] value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; error = Error(42)\n        &gt;&gt;&gt; await async_next(error.async_iter_error(), 0)\n        42\n        &gt;&gt;&gt; ok = Ok(13)\n        &gt;&gt;&gt; await async_next(ok.async_iter_error(), 0)\n        0\n        ```\n\n    Returns:\n        An asynchronous iterator over the possibly contained error value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.and_then","title":"<code>and_then(function: Unary[T, Result[U, E]]) -&gt; Result[U, E]</code>","text":"<p>Returns the result if it is an <code>Error[E]</code>, otherwise calls the <code>function</code> with the wrapped value and returns the result.</p> <p>This function is also known as bind in functional programming.</p> Example <pre><code>class InverseError(Enum):\n    DIVISION_BY_ZERO = \"division by zero\"\n\ndef inverse(value: float) -&gt; Result[float, InverseError]:\n    return Ok(1.0 / value) if value else Error(InverseError.DIVISION_BY_ZERO)\n\ntwo = Ok(2.0)\nprint(two.and_then(inverse).unwrap())  # 0.5\n\nzero = Ok(0.0)\nprint(zero.and_then(inverse).unwrap_error())  # division by zero\n\nerror = Error(1.0)\nprint(error.and_then(inverse).unwrap_error())  # 1.0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[T, Result[U, E]]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Result[U, E]</code> <p>The bound result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef and_then(self, function: Unary[T, Result[U, E]]) -&gt; Result[U, E]:\n    \"\"\"Returns the result if it is an [`Error[E]`][wraps_core.result.Error],\n    otherwise calls the `function` with the wrapped value and returns the result.\n\n    This function is also known as *bind* in functional programming.\n\n    Example:\n        ```python\n        class InverseError(Enum):\n            DIVISION_BY_ZERO = \"division by zero\"\n\n        def inverse(value: float) -&gt; Result[float, InverseError]:\n            return Ok(1.0 / value) if value else Error(InverseError.DIVISION_BY_ZERO)\n\n        two = Ok(2.0)\n        print(two.and_then(inverse).unwrap())  # 0.5\n\n        zero = Ok(0.0)\n        print(zero.and_then(inverse).unwrap_error())  # division by zero\n\n        error = Error(1.0)\n        print(error.and_then(inverse).unwrap_error())  # 1.0\n        ```\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The bound result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.and_then_await","title":"<code>and_then_await(function: AsyncUnary[T, Result[U, E]]) -&gt; Result[U, E]</code>  <code>async</code>","text":"<p>Returns the result if it is an <code>Error[E]</code>, otherwise calls the asynchronous <code>function</code> with the wrapped value and returns the result.</p> Example <pre><code>class InverseError(Enum):\n    DIVISION_BY_ZERO = \"division by zero\"\n\nasync def inverse(value: float) -&gt; Result[float, InverseError]:\n    return Ok(1.0 / value) if value else Error(InverseError.DIVISION_BY_ZERO)\n\ntwo = Ok(2.0)\nprint((await two.and_then_await(inverse)).unwrap())  # 0.5\n\nzero = Ok(0.0)\nprint((await zero.and_then_await(inverse)).unwrap_error())  # division by zero\n\nerror = Error(1.0)\nprint((await error.and_then_await(inverse)).unwrap_error())  # 1.0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[T, Result[U, E]]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Result[U, E]</code> <p>The bound result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def and_then_await(self, function: AsyncUnary[T, Result[U, E]]) -&gt; Result[U, E]:\n    \"\"\"Returns the result if it is an [`Error[E]`][wraps_core.result.Error],\n    otherwise calls the asynchronous `function` with the wrapped value and returns the result.\n\n    Example:\n        ```python\n        class InverseError(Enum):\n            DIVISION_BY_ZERO = \"division by zero\"\n\n        async def inverse(value: float) -&gt; Result[float, InverseError]:\n            return Ok(1.0 / value) if value else Error(InverseError.DIVISION_BY_ZERO)\n\n        two = Ok(2.0)\n        print((await two.and_then_await(inverse)).unwrap())  # 0.5\n\n        zero = Ok(0.0)\n        print((await zero.and_then_await(inverse)).unwrap_error())  # division by zero\n\n        error = Error(1.0)\n        print((await error.and_then_await(inverse)).unwrap_error())  # 1.0\n        ```\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The bound result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.or_else","title":"<code>or_else(function: Unary[E, Result[T, F]]) -&gt; Result[T, F]</code>","text":"<p>Returns the result if it is <code>Ok[T]</code>, otherwise calls the <code>function</code> with the wrapped error value and returns the result.</p> Example <pre><code>class NonZeroError(Enum):\n    ZERO = \"the value is zero\"\n\ndef check_non_zero(value: int) -&gt; Result[int, NonZeroError]:\n    return Ok(value) if value else Error(NonZeroError.ZERO)\n\nfive = Error(5)\nprint(error.or_else(check_non_zero).unwrap())  # 13\n\nzero = Error(0)\nprint(zero.or_else(check_non_zero).unwrap_error())  # the value is zero\n\none = Ok(1)\nprint(one.or_else(check_non_zero).unwrap())  # 1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[E, Result[T, F]]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Result[T, F]</code> <p>The bound result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef or_else(self, function: Unary[E, Result[T, F]]) -&gt; Result[T, F]:\n    \"\"\"Returns the result if it is [`Ok[T]`][wraps_core.result.Ok], otherwise calls the `function`\n    with the wrapped error value and returns the result.\n\n    Example:\n        ```python\n        class NonZeroError(Enum):\n            ZERO = \"the value is zero\"\n\n        def check_non_zero(value: int) -&gt; Result[int, NonZeroError]:\n            return Ok(value) if value else Error(NonZeroError.ZERO)\n\n        five = Error(5)\n        print(error.or_else(check_non_zero).unwrap())  # 13\n\n        zero = Error(0)\n        print(zero.or_else(check_non_zero).unwrap_error())  # the value is zero\n\n        one = Ok(1)\n        print(one.or_else(check_non_zero).unwrap())  # 1\n        ```\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The bound result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.or_else_await","title":"<code>or_else_await(function: AsyncUnary[E, Result[T, F]]) -&gt; Result[T, F]</code>  <code>async</code>","text":"<p>Returns the result if it is <code>Ok[T]</code>, otherwise calls the asynchronous <code>function</code> with the wrapped error value and returns the result.</p> Example <pre><code>class NonZeroError(Enum):\n    ZERO = \"the value is zero\"\n\nasync def check_non_zero(value: int) -&gt; Result[int, NonZeroError]:\n    return Ok(value) if value else Error(NonZeroError.ZERO)\n\nfive = Error(5)\n\nprint((await error.or_else_await(check_non_zero)).unwrap())  # 13\n\nzero = Error(0)\nprint((await zero.or_else_await(check_non_zero)).unwrap_error())  # the value is zero\n\none = Ok(1)\nprint((await ok.or_else_await(check_non_zero)).unwrap())  # 1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[E, Result[T, F]]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Result[T, F]</code> <p>The bound result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\nasync def or_else_await(self, function: AsyncUnary[E, Result[T, F]]) -&gt; Result[T, F]:\n    \"\"\"Returns the result if it is [`Ok[T]`][wraps_core.result.Ok], otherwise calls the asynchronous\n    `function` with the wrapped error value and returns the result.\n\n    Example:\n        ```python\n        class NonZeroError(Enum):\n            ZERO = \"the value is zero\"\n\n        async def check_non_zero(value: int) -&gt; Result[int, NonZeroError]:\n            return Ok(value) if value else Error(NonZeroError.ZERO)\n\n        five = Error(5)\n\n        print((await error.or_else_await(check_non_zero)).unwrap())  # 13\n\n        zero = Error(0)\n        print((await zero.or_else_await(check_non_zero)).unwrap_error())  # the value is zero\n\n        one = Ok(1)\n        print((await ok.or_else_await(check_non_zero)).unwrap())  # 1\n        ```\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The bound result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.try_flatten","title":"<code>try_flatten() -&gt; Result[T, E]</code>","text":"<p>Flattens a <code>Result[Result[T, E], E]</code> into a <code>Result[T, E]</code>.</p> <p>This is equivalent to <code>result.and_then(identity)</code>.</p> Example <pre><code>ok = Ok(42)\nok_nested = Ok(ok)\nassert ok_nested.try_flatten() == ok\n\nerror = Error(13)\nerror_nested = Ok(error)\nassert error_nested.try_flatten() == error\n\nassert error.try_flatten() == error\n</code></pre> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The flattened result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>def try_flatten(self: ResultProtocol[ResultProtocol[T, E], E]) -&gt; Result[T, E]:\n    \"\"\"Flattens a [`Result[Result[T, E], E]`][wraps_core.result.Result]\n    into a [`Result[T, E]`][wraps_core.result.Result].\n\n    This is equivalent to [`result.and_then(identity)`][wraps_core.result.ResultProtocol.and_then].\n\n    Example:\n        ```python\n        ok = Ok(42)\n        ok_nested = Ok(ok)\n        assert ok_nested.try_flatten() == ok\n\n        error = Error(13)\n        error_nested = Ok(error)\n        assert error_nested.try_flatten() == error\n\n        assert error.try_flatten() == error\n        ```\n\n    Returns:\n        The flattened result.\n    \"\"\"\n    return self.and_then(identity)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.try_flatten_error","title":"<code>try_flatten_error() -&gt; Result[T, E]</code>","text":"<p>Flattens a <code>Result[T, Result[T, E]]</code> into a <code>Result[T, E]</code>.</p> <p>This is equivalent to <code>result.or_else(identity)</code>.</p> Example <pre><code>ok = Ok(42)\nok_nested = Error(ok)\nassert ok_nested.try_flatten_error() == error\n\nerror = Error(13)\nerror_nested = Error(error)\nassert error_nested.try_flatten_error() == error\n\nassert ok.try_flatten_error() == ok\n</code></pre> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The flattened result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>def try_flatten_error(self: ResultProtocol[T, ResultProtocol[T, E]]) -&gt; Result[T, E]:\n    \"\"\"Flattens a [`Result[T, Result[T, E]]`][wraps_core.result.Result]\n    into a [`Result[T, E]`][wraps_core.result.Result].\n\n    This is equivalent to [`result.or_else(identity)`][wraps_core.result.ResultProtocol.or_else].\n\n    Example:\n        ```python\n        ok = Ok(42)\n        ok_nested = Error(ok)\n        assert ok_nested.try_flatten_error() == error\n\n        error = Error(13)\n        error_nested = Error(error)\n        assert error_nested.try_flatten_error() == error\n\n        assert ok.try_flatten_error() == ok\n        ```\n\n    Returns:\n        The flattened result.\n    \"\"\"\n    return self.or_else(identity)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.contains","title":"<code>contains(value: U) -&gt; bool</code>","text":"<p>Checks if the contained value is equal to the <code>value</code>.</p> Example <pre><code>value = 42\nother = 69\n\nok = Ok(value)\nassert ok.contains(value)\nassert not ok.contains(other)\n\nerror = Error(value)\nassert not error.contains(value)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>U</code> <p>The value to check against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the contained value is equal to the <code>value</code>.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef contains(self, value: U) -&gt; bool:\n    \"\"\"Checks if the contained value is equal to the `value`.\n\n    Example:\n        ```python\n        value = 42\n        other = 69\n\n        ok = Ok(value)\n        assert ok.contains(value)\n        assert not ok.contains(other)\n\n        error = Error(value)\n        assert not error.contains(value)\n        ```\n\n    Arguments:\n        value: The value to check against.\n\n    Returns:\n        Whether the contained value is equal to the `value`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.contains_error","title":"<code>contains_error(error: F) -&gt; bool</code>","text":"<p>Checks if the contained error value is equal to the <code>error</code>.</p> Example <pre><code>value = 42\nother = 69\n\nerror = Error(value)\nassert error.contains_error(value)\nassert not error.contains_error(other)\n\nok = Ok(value)\nassert not ok.contains_error(value)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>F</code> <p>The error value to check against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the contained error value is equal to the <code>error</code>.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef contains_error(self, error: F) -&gt; bool:\n    \"\"\"Checks if the contained error value is equal to the `error`.\n\n    Example:\n        ```python\n        value = 42\n        other = 69\n\n        error = Error(value)\n        assert error.contains_error(value)\n        assert not error.contains_error(other)\n\n        ok = Ok(value)\n        assert not ok.contains_error(value)\n        ```\n\n    Arguments:\n        error: The error value to check against.\n\n    Returns:\n        Whether the contained error value is equal to the `error`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.flip","title":"<code>flip() -&gt; Result[E, T]</code>","text":"<p>Converts a <code>Result[T, E]</code> into a <code>Result[E, T]</code>.</p> <p><code>Ok(value)</code> and <code>Error(error)</code> get swapped to <code>Error(value)</code> and <code>Ok(error)</code> respectively.</p> Example <pre><code>value = 42\n\nresult = Ok(value)\nflipped = Error(value)\n\nassert result.flip() == flipped\n</code></pre> <p>Returns:</p> Type Description <code>Result[E, T]</code> <p>The flipped result.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef flip(self) -&gt; Result[E, T]:\n    \"\"\"Converts a [`Result[T, E]`][wraps_core.result.Result]\n    into a [`Result[E, T]`][wraps_core.result.Result].\n\n    [`Ok(value)`][wraps_core.result.Ok] and [`Error(error)`][wraps_core.result.Error] get swapped to\n    [`Error(value)`][wraps_core.result.Error] and [`Ok(error)`][wraps_core.result.Ok] respectively.\n\n    Example:\n        ```python\n        value = 42\n\n        result = Ok(value)\n        flipped = Error(value)\n\n        assert result.flip() == flipped\n        ```\n\n    Returns:\n        The flipped result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.into_ok_or_error","title":"<code>into_ok_or_error() -&gt; V</code>","text":"<p>Returns the value contained within <code>Result[V, V]</code>, regardless of whether or not that result is <code>Ok[V]</code> or <code>Error[V]</code>.</p> Example <pre><code>result: Result[int, int] = Ok(69)\n\nprint(result.into_ok_or_error())  # 69; inferred `int`\n\nresult = Error(42)\n\nprint(result.into_ok_or_error())  # 42; inferred `int`\n</code></pre> <p>Returns:</p> Type Description <code>V</code> <p>The contained value, regardless of whether or not it is an error one.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef into_ok_or_error(self: ResultProtocol[V, V]) -&gt; V:\n    \"\"\"Returns the value contained within [`Result[V, V]`][wraps_core.result.Result], regardless\n    of whether or not that result is [`Ok[V]`][wraps_core.result.Ok]\n    or [`Error[V]`][wraps_core.result.Error].\n\n    Example:\n        ```python\n        result: Result[int, int] = Ok(69)\n\n        print(result.into_ok_or_error())  # 69; inferred `int`\n\n        result = Error(42)\n\n        print(result.into_ok_or_error())  # 42; inferred `int`\n        ```\n\n    Returns:\n        The contained value, regardless of whether or not it is an error one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.into_either","title":"<code>into_either() -&gt; Either[T, E]</code>","text":"<p>Converts a <code>Result[T, E]</code> into an <code>Either[T, E]</code>.</p> <p><code>Ok(value)</code> is mapped to <code>Left(value)</code> and <code>Error(error)</code> is mapped to <code>Right(error)</code>.</p> Example <pre><code>value = 42\n\nok = Ok(value)\nleft = Left(value)\n\nassert ok.into_either() == left\n\nerror = Error(value)\nright = Right(value)\n\nassert error.into_either() == right\n</code></pre> <p>Returns:</p> Type Description <code>Either[T, E]</code> <p>The mapped either.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef into_either(self) -&gt; Either[T, E]:\n    \"\"\"Converts a [`Result[T, E]`][wraps_core.result.Result]\n    into an [`Either[T, E]`][wraps_core.either.Either].\n\n    [`Ok(value)`][wraps_core.result.Ok] is mapped to [`Left(value)`][wraps_core.either.Left]\n    and [`Error(error)`][wraps_core.result.Error] is mapped to [`Right(error)`][wraps_core.either.Right].\n\n    Example:\n        ```python\n        value = 42\n\n        ok = Ok(value)\n        left = Left(value)\n\n        assert ok.into_either() == left\n\n        error = Error(value)\n        right = Right(value)\n\n        assert error.into_either() == right\n        ```\n\n    Returns:\n        The mapped either.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.ResultProtocol.early","title":"<code>early() -&gt; T</code>","text":"<p>Functionally similar to the question-mark (<code>?</code>) operator in Rust.</p> <p>Calls to this method are to be combined with <code>@early_result</code> decorators to work properly.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@required\ndef early(self) -&gt; T:\n    \"\"\"Functionally similar to the *question-mark* (`?`) operator in Rust.\n\n    Calls to this method are to be combined with\n    [`@early_result`][wraps_core.early.decorators.early_result] decorators to work properly.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps_core.result.Ok","title":"<code>Ok</code>","text":"<p>               Bases: <code>ResultProtocol[T, Never]</code></p> <p><code>Ok[T]</code> variant of <code>Result[T, E]</code>.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@final\n@frozen()\nclass Ok(ResultProtocol[T, Never]):\n    \"\"\"[`Ok[T]`][wraps_core.result.Ok] variant of [`Result[T, E]`][wraps_core.result.Result].\"\"\"\n\n    value: T\n\n    def __repr__(self) -&gt; str:\n        return wrap_repr(self, self.value)\n\n    @classmethod\n    def create(cls, value: U) -&gt; Ok[U]:\n        return cls(value)  # type: ignore[arg-type, return-value]\n\n    def is_ok(self) -&gt; Literal[True]:\n        return True\n\n    def is_ok_and(self, predicate: Predicate[T]) -&gt; bool:\n        return predicate(self.value)\n\n    async def is_ok_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n        return await predicate(self.value)\n\n    def is_error(self) -&gt; Literal[False]:\n        return False\n\n    def is_error_and(self, predicate: Predicate[E]) -&gt; Literal[False]:\n        return False\n\n    async def is_error_and_await(self, predicate: AsyncPredicate[E]) -&gt; Literal[False]:\n        return False\n\n    def expect(self, message: str) -&gt; T:\n        return self.value\n\n    def expect_error(self, message: str) -&gt; Never:\n        panic(message)\n\n    def unwrap(self) -&gt; T:\n        return self.value\n\n    def unwrap_or(self, default: U) -&gt; T:\n        return self.value\n\n    def unwrap_or_else(self, default: Nullary[U]) -&gt; T:\n        return self.value\n\n    async def unwrap_or_else_await(self, default: AsyncNullary[U]) -&gt; T:\n        return self.value\n\n    def or_raise(self, error: AnyError) -&gt; T:\n        return self.value\n\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n        return self.value\n\n    async def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n        return self.value\n\n    def unwrap_error(self) -&gt; Never:\n        panic(UNWRAP_ERROR_ON_OK)\n\n    def unwrap_error_or(self, default: F) -&gt; F:\n        return default\n\n    def unwrap_error_or_else(self, default: Nullary[F]) -&gt; F:\n        return default()\n\n    async def unwrap_error_or_else_await(self, default: AsyncNullary[F]) -&gt; F:\n        return await default()\n\n    def raising(self) -&gt; T:\n        return self.value\n\n    def ok(self) -&gt; Some[T]:\n        return Some(self.value)\n\n    def error(self) -&gt; Null:\n        return NULL\n\n    def inspect(self, function: Inspect[T]) -&gt; Ok[T]:\n        function(self.value)\n\n        return self\n\n    async def inspect_await(self, function: AsyncInspect[T]) -&gt; Ok[T]:\n        await function(self.value)\n\n        return self\n\n    def inspect_error(self, function: Inspect[E]) -&gt; Ok[T]:\n        return self\n\n    async def inspect_error_await(self, function: AsyncInspect[E]) -&gt; Ok[T]:\n        return self\n\n    def map(self, function: Unary[T, U]) -&gt; Ok[U]:\n        return self.create(function(self.value))\n\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        return function(self.value)\n\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        return function(self.value)\n\n    def map_error(self, function: Unary[E, F]) -&gt; Ok[T]:\n        return self\n\n    def map_error_or(self, default: F, function: Unary[E, F]) -&gt; F:\n        return default\n\n    def map_error_or_else(self, default: Nullary[F], function: Unary[E, F]) -&gt; F:\n        return default()\n\n    async def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        return function(self.value)\n\n    async def map_error_or_else_await(self, default: AsyncNullary[F], function: Unary[E, F]) -&gt; F:\n        return await default()\n\n    async def map_await(self, function: AsyncUnary[T, U]) -&gt; Ok[U]:\n        return self.create(await function(self.value))\n\n    async def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        return await function(self.value)\n\n    async def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        return await function(self.value)\n\n    async def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        return await function(self.value)\n\n    async def map_error_await(self, function: AsyncUnary[E, F]) -&gt; Ok[T]:\n        return self\n\n    async def map_error_await_or(self, default: F, function: AsyncUnary[E, F]) -&gt; F:\n        return default\n\n    async def map_error_await_or_else(self, default: Nullary[F], function: AsyncUnary[E, F]) -&gt; F:\n        return default()\n\n    async def map_error_await_or_else_await(\n        self, default: AsyncNullary[F], function: AsyncUnary[E, F]\n    ) -&gt; F:\n        return await default()\n\n    def iter(self) -&gt; Iterator[T]:\n        return once(self.value)\n\n    def iter_error(self) -&gt; Iterator[Never]:\n        return empty()\n\n    def async_iter(self) -&gt; AsyncIterator[T]:\n        return async_once(self.value)\n\n    def async_iter_error(self) -&gt; AsyncIterator[Never]:\n        return async_empty()\n\n    def and_then(self, function: Unary[T, Result[U, E]]) -&gt; Result[U, E]:\n        return function(self.value)\n\n    async def and_then_await(self, function: AsyncUnary[T, Result[U, E]]) -&gt; Result[U, E]:\n        return await function(self.value)\n\n    def or_else(self, function: Unary[E, Result[T, F]]) -&gt; Ok[T]:\n        return self\n\n    async def or_else_await(self, function: AsyncUnary[E, Result[T, F]]) -&gt; Ok[T]:\n        return self\n\n    def contains(self, value: U) -&gt; bool:\n        return self.value == value\n\n    def contains_error(self, error: F) -&gt; Literal[False]:\n        return False\n\n    def flip(self) -&gt; Error[T]:\n        return Error(self.value)\n\n    def into_ok_or_error(self: Ok[V]) -&gt; V:\n        return self.value\n\n    def into_either(self) -&gt; Left[T]:\n        return Left(self.value)\n\n    def early(self) -&gt; T:\n        return self.value\n</code></pre>"},{"location":"reference/result/#wraps_core.result.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>ResultProtocol[Never, E]</code></p> <p><code>Error[E]</code> variant of <code>Result[T, E]</code>.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@final\n@frozen()\nclass Error(ResultProtocol[Never, E]):\n    \"\"\"[`Error[E]`][wraps_core.result.Error] variant of [`Result[T, E]`][wraps_core.result.Result].\"\"\"\n\n    value: E\n\n    def __bool__(self) -&gt; Literal[False]:\n        return False\n\n    def __repr__(self) -&gt; str:\n        return wrap_repr(self, self.value)\n\n    @classmethod\n    def create(cls, error: F) -&gt; Error[F]:\n        return cls(error)  # type: ignore[arg-type, return-value]\n\n    def is_ok(self) -&gt; Literal[False]:\n        return False\n\n    def is_ok_and(self, predicate: Predicate[T]) -&gt; Literal[False]:\n        return False\n\n    async def is_ok_and_await(self, predicate: AsyncPredicate[T]) -&gt; Literal[False]:\n        return False\n\n    def is_error(self) -&gt; Literal[True]:\n        return True\n\n    def is_error_and(self, predicate: Predicate[E]) -&gt; bool:\n        return predicate(self.value)\n\n    async def is_error_and_await(self, predicate: AsyncPredicate[E]) -&gt; bool:\n        return await predicate(self.value)\n\n    def ok(self) -&gt; Null:\n        return NULL\n\n    def error(self) -&gt; Some[E]:\n        return Some(self.value)\n\n    def expect(self, message: str) -&gt; Never:\n        panic(message)\n\n    def unwrap(self) -&gt; Never:\n        panic(UNWRAP_ON_ERROR)\n\n    def expect_error(self, message: str) -&gt; E:\n        return self.value\n\n    def unwrap_error(self) -&gt; E:\n        return self.value\n\n    def unwrap_or(self, default: U) -&gt; U:\n        return default\n\n    def unwrap_or_else(self, default: Nullary[U]) -&gt; U:\n        return default()\n\n    async def unwrap_or_else_await(self, default: AsyncNullary[U]) -&gt; U:\n        return await default()\n\n    def or_raise(self, error: AnyError) -&gt; Never:\n        raise error\n\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; Never:\n        raise error()\n\n    async def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; Never:\n        raise await error()\n\n    def unwrap_error_or(self, default: F) -&gt; E:\n        return self.value\n\n    def unwrap_error_or_else(self, default: Nullary[F]) -&gt; E:\n        return self.value\n\n    async def unwrap_error_or_else_await(self, default: AsyncNullary[F]) -&gt; E:\n        return self.value\n\n    def raising(self: Error[AnyError]) -&gt; Never:\n        raise self.value\n\n    def inspect(self, function: Inspect[T]) -&gt; Error[E]:\n        return self\n\n    async def inspect_await(self, function: AsyncInspect[T]) -&gt; Error[E]:\n        return self\n\n    def inspect_error(self, function: Inspect[E]) -&gt; Error[E]:\n        function(self.value)\n\n        return self\n\n    async def inspect_error_await(self, function: AsyncInspect[E]) -&gt; Error[E]:\n        await function(self.value)\n\n        return self\n\n    def map(self, function: Unary[T, U]) -&gt; Error[E]:\n        return self\n\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        return default\n\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        return default()\n\n    def map_error(self, function: Unary[E, F]) -&gt; Error[F]:\n        return self.create(function(self.value))\n\n    def map_error_or(self, default: F, function: Unary[E, F]) -&gt; F:\n        return function(self.value)\n\n    def map_error_or_else(self, default: Nullary[F], function: Unary[E, F]) -&gt; F:\n        return function(self.value)\n\n    async def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        return await default()\n\n    async def map_error_or_else_await(self, default: AsyncNullary[F], function: Unary[E, F]) -&gt; F:\n        return function(self.value)\n\n    async def map_await(self, function: AsyncUnary[T, U]) -&gt; Error[E]:\n        return self\n\n    async def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        return default\n\n    async def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        return default()\n\n    async def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        return await default()\n\n    async def map_error_await(self, function: AsyncUnary[E, F]) -&gt; Error[F]:\n        return self.create(await function(self.value))\n\n    async def map_error_await_or(self, default: F, function: AsyncUnary[E, F]) -&gt; F:\n        return await function(self.value)\n\n    async def map_error_await_or_else(self, default: Nullary[F], function: AsyncUnary[E, F]) -&gt; F:\n        return await function(self.value)\n\n    async def map_error_await_or_else_await(\n        self, default: AsyncNullary[F], function: AsyncUnary[E, F]\n    ) -&gt; F:\n        return await function(self.value)\n\n    def iter(self) -&gt; Iterator[Never]:\n        return empty()\n\n    def iter_error(self) -&gt; Iterator[E]:\n        return once(self.value)\n\n    def async_iter(self) -&gt; AsyncIterator[Never]:\n        return async_empty()\n\n    def async_iter_error(self) -&gt; AsyncIterator[E]:\n        return async_once(self.value)\n\n    def and_then(self, function: Unary[T, Result[U, E]]) -&gt; Error[E]:\n        return self\n\n    async def and_then_await(self, function: AsyncUnary[T, Result[U, E]]) -&gt; Error[E]:\n        return self\n\n    def or_else(self, function: Unary[E, Result[T, F]]) -&gt; Result[T, F]:\n        return function(self.value)\n\n    async def or_else_await(self, function: AsyncUnary[E, Result[T, F]]) -&gt; Result[T, F]:\n        return await function(self.value)\n\n    def contains(self, value: U) -&gt; Literal[False]:\n        return False\n\n    def contains_error(self, error: F) -&gt; bool:\n        return self.value == error\n\n    def flip(self) -&gt; Ok[E]:\n        return Ok(self.value)\n\n    def into_ok_or_error(self: Error[V]) -&gt; V:\n        return self.value\n\n    def into_either(self) -&gt; Right[E]:\n        return Right(self.value)\n\n    def early(self) -&gt; Never:\n        raise EarlyResult(self.value)\n</code></pre>"},{"location":"reference/result/#wraps_core.result.WrapResult","title":"<code>WrapResult</code>","text":"<p>               Bases: <code>Generic[A]</code></p> <p>Wraps functions returning <code>T</code> into functions returning <code>Result[T, E]</code>.</p> <p>Errors are handled via returning <code>Error(error)</code> on <code>error</code> of <code>error_types</code>, wrapping the resulting <code>value</code> into <code>Ok(value)</code>.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@final\n@frozen()\nclass WrapResult(Generic[A]):\n    \"\"\"Wraps functions returning `T` into functions returning\n    [`Result[T, E]`][wraps_core.result.Result].\n\n    Errors are handled via returning [`Error(error)`][wraps_core.result.Error] on `error` of\n    [`error_types`][wraps_core.result.WrapResult.error_types], wrapping the resulting\n    `value` into [`Ok(value)`][wraps_core.result.Ok].\n    \"\"\"\n\n    error_types: ErrorTypes[A]\n    \"\"\"The error types to handle. See [`ErrorTypes[A]`][wraps_core.errors.ErrorTypes].\"\"\"\n\n    def __call__(self, function: Callable[P, T]) -&gt; ResultCallable[P, T, A]:\n        @wraps(function)\n        def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Result[T, A]:\n            try:\n                return Ok(function(*args, **kwargs))\n\n            except self.error_types.extract() as error:\n                return Error(error)\n\n        return wrap\n</code></pre>"},{"location":"reference/result/#wraps_core.result.WrapResult.error_types","title":"<code>error_types: ErrorTypes[A]</code>  <code>instance-attribute</code>","text":"<p>The error types to handle. See <code>ErrorTypes[A]</code>.</p>"},{"location":"reference/result/#wraps_core.result.WrapResultAwait","title":"<code>WrapResultAwait</code>","text":"<p>               Bases: <code>Generic[A]</code></p> <p>Wraps asynchronous functions returning <code>T</code> into asynchronous functions returning <code>Result[T, E]</code>.</p> <p>Errors are handled via returning <code>Error(error)</code> on <code>error</code> of <code>error_types</code>, wrapping the resulting <code>value</code> into <code>Ok(value)</code>.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>@final\n@frozen()\nclass WrapResultAwait(Generic[A]):\n    \"\"\"Wraps asynchronous functions returning `T` into asynchronous functions returning\n    [`Result[T, E]`][wraps_core.result.Result].\n\n    Errors are handled via returning [`Error(error)`][wraps_core.result.Error] on `error` of\n    [`error_types`][wraps_core.result.WrapResult.error_types], wrapping the resulting\n    `value` into [`Ok(value)`][wraps_core.result.Ok].\n    \"\"\"\n\n    error_types: ErrorTypes[A]\n    \"\"\"The error types to handle. See [`ErrorTypes[A]`][wraps_core.errors.ErrorTypes].\"\"\"\n\n    def __call__(self, function: AsyncCallable[P, T]) -&gt; ResultAsyncCallable[P, T, A]:\n        @wraps(function)\n        async def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Result[T, A]:\n            try:\n                return Ok(await function(*args, **kwargs))\n\n            except self.error_types.extract() as error:\n                return Error(error)\n\n        return wrap\n</code></pre>"},{"location":"reference/result/#wraps_core.result.WrapResultAwait.error_types","title":"<code>error_types: ErrorTypes[A]</code>  <code>instance-attribute</code>","text":"<p>The error types to handle. See <code>ErrorTypes[A]</code>.</p>"},{"location":"reference/result/#wraps_core.result.is_ok","title":"<code>is_ok(result: Result[T, E]) -&gt; TypeIs[Ok[T]]</code>","text":"<p>This is the same as <code>Result.is_ok</code>, except it works as a type guard.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>def is_ok(result: Result[T, E]) -&gt; TypeIs[Ok[T]]:\n    \"\"\"This is the same as [`Result.is_ok`][wraps_core.result.ResultProtocol.is_ok],\n    except it works as a *type guard*.\n    \"\"\"\n    return result.is_ok()\n</code></pre>"},{"location":"reference/result/#wraps_core.result.is_error","title":"<code>is_error(result: Result[T, E]) -&gt; TypeIs[Error[E]]</code>","text":"<p>This is the same as <code>Result.is_error</code>, except it works as a type guard.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>def is_error(result: Result[T, E]) -&gt; TypeIs[Error[E]]:\n    \"\"\"This is the same as [`Result.is_error`][wraps_core.result.ResultProtocol.is_error],\n    except it works as a *type guard*.\n    \"\"\"\n    return result.is_error()\n</code></pre>"},{"location":"reference/result/#wraps_core.result.wrap_result_on","title":"<code>wrap_result_on(head: Type[A], *tail: Type[A]) -&gt; WrapResult[A]</code>","text":"<p>Creates <code>WrapResult[A]</code> decorators.</p> <p>This function enforces at least one error type to be provided.</p> Example <pre><code>@wrap_result_on(ValueError)\ndef parse(string: str) -&gt; int:\n    return int(string)\n\nassert parse(\"128\").is_ok()\nassert parse(\"owo\").is_error()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>head</code> <code>Type[A]</code> <p>The head of the error types to handle.</p> required <code>*tail</code> <code>Type[A]</code> <p>The tail of the error types to handle.</p> <code>()</code> <p>Returns:</p> Type Description <code>WrapResult[A]</code> <p>The <code>WrapResult[A]</code> decorator created.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>def wrap_result_on(head: Type[A], *tail: Type[A]) -&gt; WrapResult[A]:\n    \"\"\"Creates [`WrapResult[A]`][wraps_core.result.WrapResult] decorators.\n\n    This function enforces at least one error type to be provided.\n\n    Example:\n        ```python\n        @wrap_result_on(ValueError)\n        def parse(string: str) -&gt; int:\n            return int(string)\n\n        assert parse(\"128\").is_ok()\n        assert parse(\"owo\").is_error()\n        ```\n\n    Arguments:\n        head: The head of the error types to handle.\n        *tail: The tail of the error types to handle.\n\n    Returns:\n        The [`WrapResult[A]`][wraps_core.result.WrapResult] decorator created.\n    \"\"\"\n    return WrapResult(ErrorTypes[A].from_head_and_tail(head, *tail))\n</code></pre>"},{"location":"reference/result/#wraps_core.result.wrap_result_await_on","title":"<code>wrap_result_await_on(head: Type[A], *tail: Type[A]) -&gt; WrapResultAwait[A]</code>","text":"<p>Creates <code>WrapResultAwait[A]</code> decorators.</p> <p>This function enforces at least one error type to be provided.</p> Example <pre><code>@wrap_result_await_on(ValueError)\nasync def parse(string: str) -&gt; int:\n    return int(string)\n\nassert (await parse(\"128\")).is_ok()\nassert (await parse(\"owo\")).is_error()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>head</code> <code>Type[A]</code> <p>The head of the error types to handle.</p> required <code>*tail</code> <code>Type[A]</code> <p>The tail of the error types to handle.</p> <code>()</code> <p>Returns:</p> Type Description <code>WrapResultAwait[A]</code> <p>The <code>WrapResultAwait[A]</code> decorator created.</p> Source code in <code>src/wraps_core/result.py</code> <pre><code>def wrap_result_await_on(head: Type[A], *tail: Type[A]) -&gt; WrapResultAwait[A]:\n    \"\"\"Creates [`WrapResultAwait[A]`][wraps_core.result.WrapResultAwait] decorators.\n\n    This function enforces at least one error type to be provided.\n\n    Example:\n        ```python\n        @wrap_result_await_on(ValueError)\n        async def parse(string: str) -&gt; int:\n            return int(string)\n\n        assert (await parse(\"128\")).is_ok()\n        assert (await parse(\"owo\")).is_error()\n        ```\n\n    Arguments:\n        head: The head of the error types to handle.\n        *tail: The tail of the error types to handle.\n\n    Returns:\n        The [`WrapResultAwait[A]`][wraps_core.result.WrapResultAwait] decorator created.\n    \"\"\"\n    return WrapResultAwait(ErrorTypes[A].from_head_and_tail(head, *tail))\n</code></pre>"},{"location":"reference/typing/","title":"Typing","text":"<p>Various type aliases.</p>"},{"location":"reference/typing/#wraps_core.typing.OptionCallable","title":"<code>OptionCallable = Callable[P, Option[T]]</code>  <code>module-attribute</code>","text":"<p>Represents option callables <code>(**P) -&gt; Option[T]</code>.</p>"},{"location":"reference/typing/#wraps_core.typing.OptionAsyncCallable","title":"<code>OptionAsyncCallable = AsyncCallable[P, Option[T]]</code>  <code>module-attribute</code>","text":"<p>Represents option async callables <code>async (**P) -&gt; Option[T]</code>.</p>"},{"location":"reference/typing/#wraps_core.typing.ResultCallable","title":"<code>ResultCallable = Callable[P, Result[T, E]]</code>  <code>module-attribute</code>","text":"<p>Represents result callables <code>(**P) -&gt; Result[T, E]</code>.</p>"},{"location":"reference/typing/#wraps_core.typing.ResultAsyncCallable","title":"<code>ResultAsyncCallable = AsyncCallable[P, Result[T, E]]</code>  <code>module-attribute</code>","text":"<p>Represents result async callables <code>async (**P) -&gt; Result[T, E]</code>.</p>"},{"location":"reference/typing/#wraps_core.typing.EitherCallable","title":"<code>EitherCallable = Callable[P, Either[L, R]]</code>  <code>module-attribute</code>","text":"<p>Represents either callables <code>(**P) -&gt; Either[L, R]</code>.</p>"},{"location":"reference/typing/#wraps_core.typing.EitherAsyncCallable","title":"<code>EitherAsyncCallable = AsyncCallable[P, Either[L, R]]</code>  <code>module-attribute</code>","text":"<p>Represents either async callables <code>async (**P) -&gt; Either[L, R]</code>.</p>"},{"location":"reference/early/decorators/","title":"Decorators","text":"<p>Early return decorators.</p>"},{"location":"reference/early/decorators/#wraps_core.early.decorators.early_option","title":"<code>early_option(function: OptionCallable[P, T]) -&gt; OptionCallable[P, T]</code>","text":"<p>Decorates the <code>function</code> returning <code>Option[T]</code> to handle early returns via the <code>early</code> (<code>?</code> in Rust) operator.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>OptionCallable[P, T]</code> <p>The function to wrap.</p> required <p>Returns:</p> Type Description <code>OptionCallable[P, T]</code> <p>The wrapping function.</p> Source code in <code>src/wraps_core/early/decorators.py</code> <pre><code>def early_option(function: OptionCallable[P, T]) -&gt; OptionCallable[P, T]:\n    \"\"\"Decorates the `function` returning [`Option[T]`][wraps_core.option.Option]\n    to handle *early returns* via the `early` (`?` in Rust) operator.\n\n    Arguments:\n        function: The function to wrap.\n\n    Returns:\n        The wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Option[T]:\n        try:\n            return function(*args, **kwargs)\n\n        except EarlyOption:\n            return NULL\n\n    return wrap\n</code></pre>"},{"location":"reference/early/decorators/#wraps_core.early.decorators.early_option_await","title":"<code>early_option_await(function: OptionAsyncCallable[P, T]) -&gt; OptionAsyncCallable[P, T]</code>","text":"<p>Decorates the asynchronous <code>function</code> returning <code>Option[T]</code> to handle early returns via the <code>early</code> (<code>?</code> in Rust) operator.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>OptionAsyncCallable[P, T]</code> <p>The asynchronous function to wrap.</p> required <p>Returns:</p> Type Description <code>OptionAsyncCallable[P, T]</code> <p>The asynchronous wrapping function.</p> Source code in <code>src/wraps_core/early/decorators.py</code> <pre><code>def early_option_await(function: OptionAsyncCallable[P, T]) -&gt; OptionAsyncCallable[P, T]:\n    \"\"\"Decorates the asynchronous `function` returning [`Option[T]`][wraps_core.option.Option]\n    to handle *early returns* via the `early` (`?` in Rust) operator.\n\n    Arguments:\n        function: The asynchronous function to wrap.\n\n    Returns:\n        The asynchronous wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    async def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Option[T]:\n        try:\n            return await function(*args, **kwargs)\n\n        except EarlyOption:\n            return NULL\n\n    return wrap\n</code></pre>"},{"location":"reference/early/decorators/#wraps_core.early.decorators.early_result","title":"<code>early_result(function: ResultCallable[P, T, E]) -&gt; ResultCallable[P, T, E]</code>","text":"<p>Decorates the <code>function</code> returning <code>Result[T, E]</code> to handle early returns via the <code>early</code> (<code>?</code> in Rust) operator.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>ResultCallable[P, T, E]</code> <p>The function to wrap.</p> required <p>Returns:</p> Type Description <code>ResultCallable[P, T, E]</code> <p>The wrapping function.</p> Source code in <code>src/wraps_core/early/decorators.py</code> <pre><code>def early_result(function: ResultCallable[P, T, E]) -&gt; ResultCallable[P, T, E]:\n    \"\"\"Decorates the `function` returning [`Result[T, E]`][wraps_core.result.Result]\n    to handle *early returns* via the `early` (`?` in Rust) operator.\n\n    Arguments:\n        function: The function to wrap.\n\n    Returns:\n        The wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Result[T, E]:\n        try:\n            return function(*args, **kwargs)\n\n        except EarlyResult[E] as early:\n            return Error(early.error)\n\n    return wrap\n</code></pre>"},{"location":"reference/early/decorators/#wraps_core.early.decorators.early_result_await","title":"<code>early_result_await(function: ResultAsyncCallable[P, T, E]) -&gt; ResultAsyncCallable[P, T, E]</code>","text":"<p>Decorates the asynchronous <code>function</code> returning <code>Result[T, E]</code> to handle early returns via the <code>early</code> (<code>?</code> in Rust) operator.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>ResultAsyncCallable[P, T, E]</code> <p>The asynchronous function to wrap.</p> required <p>Returns:</p> Type Description <code>ResultAsyncCallable[P, T, E]</code> <p>The asynchronous wrapping function.</p> Source code in <code>src/wraps_core/early/decorators.py</code> <pre><code>def early_result_await(function: ResultAsyncCallable[P, T, E]) -&gt; ResultAsyncCallable[P, T, E]:\n    \"\"\"Decorates the asynchronous `function` returning [`Result[T, E]`][wraps_core.result.Result]\n    to handle *early returns* via the `early` (`?` in Rust) operator.\n\n    Arguments:\n        function: The asynchronous function to wrap.\n\n    Returns:\n        The asynchronous wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    async def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Result[T, E]:\n        try:\n            return await function(*args, **kwargs)\n\n        except EarlyResult[E] as early:\n            return Error(early.error)\n\n    return wrap\n</code></pre>"},{"location":"reference/early/errors/","title":"Errors","text":"<p>Early return errors used for propagation.</p>"},{"location":"reference/early/errors/#wraps_core.early.errors.EarlyOption","title":"<code>EarlyOption</code>","text":"<p>               Bases: <code>AnyError</code></p> <p>The internal error raised by the <code>early</code> method.</p> Source code in <code>src/wraps_core/early/errors.py</code> <pre><code>class EarlyOption(AnyError):\n    \"\"\"The internal error raised by the [`early`][wraps_core.option.OptionProtocol.early] method.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(EARLY_OPTION_WITHOUT_DECORATOR)\n</code></pre>"},{"location":"reference/early/errors/#wraps_core.early.errors.EarlyResult","title":"<code>EarlyResult</code>","text":"<p>               Bases: <code>AnyError</code>, <code>Generic[E]</code></p> <p>The internal error raised by the <code>early</code> method.</p> Source code in <code>src/wraps_core/early/errors.py</code> <pre><code>class EarlyResult(AnyError, Generic[E]):\n    \"\"\"The internal error raised by the [`early`][wraps_core.result.ResultProtocol.early] method.\"\"\"\n\n    def __init__(self, error: E) -&gt; None:\n        super().__init__(EARLY_RESULT_WITHOUT_DECORATOR)\n\n        self._error = error\n\n    @property\n    def error(self) -&gt; E:\n        return self._error\n</code></pre>"}]}